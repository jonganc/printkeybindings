;;;; ************************************************
;; Print members of `current-global-map' for which `pkb-include-mk-p' returns nil (and which aren't members of IGNORE-EVENT or undefined)
(let ((ignore-event '(menu-bar tool-bar)))
  (insert "(")
  (map-keymap 
   (lambda (event defn)
     (unless (or (null defn)
		 (memq event ignore-event)
		 (pkb-include-mk-p event))
       (insert (concat "(" (prin1-to-string event) ": "
		       (prin1-to-string defn) ")\n"))))
   (current-global-map))
  (insert ")")
)

;;;; ************************************************
;; Returns all base-keys in mousemodded unless they are listed in mousebase and all modified-keys unless they are listed in pkb-include-mouse-modifier
(let (bases mods)
  (dolist (key mousemodded)
    (unless (memq (event-basic-type key) mousebase)
      (add-to-list 'bases (event-basic-type key) t))
    (dolist (mod (event-modifiers key))
      (unless (memq mod pkb-include-mouse-modifier)
	(add-to-list 'mods mod t))))
  (in-pr bases)
  (insert "\n")
  (in-pr mods)
)
(wheel-down wheel-up mouse-1 mouse-2 mouse-3 mouse-4)
(click drag down double triple)

;;;; ************************************************
;; Understand how keymaps work with char-ranges and Meta/ESC-map

(lookup-key (current-global-map) [27])
(in-pr (symbol-function 'ESC-prefix))

(map-keymap 'print-keymap-func (lookup-key (current-local-map) (vector 27)))

;;;; ************************************************
;; Pare keymaps


;; returns a version of (accessible-keymaps KEYMAP) without pks listed in PKS-TO-IGNORE

(defun pare-accessible-keymaps(keymap)
  (let ((pks-to-ignore '([]))
	(akmps (accessible-keymaps keymap)))
    (dolist (pref-w-keymap akmps)
      (when (member (car pref-w-keymap) pks-to-ignore)
	(setq akmps (delq pref-w-keymap akmps))))
    akmps)
)

(in-pr (pare-accessible-keymaps (current-global-map)))

;; returns a version of keymap without events in ignore-list
(defun pare-keymap (keymap) 
  (let ((ignore-list '(menu-bar tool-bar))
	(kmcopy (copy-sequence keymap)))
    (map-keymap
     (lambda (event bind)
       (when (member event ignore-list)
	   ;; (and (consp key-w-binding)
	   ;;      (not (vectorp (car key-w-binding))))
	  (define-key kmcopy (vector event) nil)))
     kmcopy)
    kmcopy)
)

;;;; ************************************************
;; Test char-ranges and keymaps

(setq tst (make-keymap))

(dolist (key
	  (let (veclst)
	    (dolist (elem (number-sequence #1=?\H-a (- #1# 20) -1))
	      (add-to-list 'veclst (vector elem) t))
	    veclst))
  (define-key tst key 'defn)
)

(dolist (key
	  (let (veclst)
	    (dolist (elem (number-sequence #1=70 (+ #1# 10)))
	      (add-to-list 'veclst (vector elem) t))
	    veclst))
  (define-key tst key 'defn)
)

(map-keymap 'print-keymap-func tst)

;;;; ************************************************
;; test pkb-accessible-keymaps

(in-pr
 (pkb-accessible-keymaps
  '(keymap (?a keymap (?b . binding) (?c . binding2))
	   (?c keymap (?d . binding3) (?g keymap (?q . binding4)))
	   (?h keymap (?p . binding5) (?\C-w keymap (?a . binding5))))
  ))

(in-pr
 (pkb-accessible-keymaps 
  '(keymap (a keymap (aa . binding) (ab . binding2))
	   (b keymap (ba . binding3) (bb keymap (bba . binding4)))
	   (c keymap
	      (ca . binding5)
	      (cb keymap
		  (cba . binding5)
		  (cbb keymap (cbba . bind)))
	      (cc keymap
		  (cca . binding5)
		  (ccb keymap (ccba . bind)))))
  '([b] [c]) '([b bb] ([c cb]))
  ))

(in-pr
 (pkb-accessible-keymaps 
  (current-global-map)
  '([?\C-x])
  ))

;;;; ************************************************
;; test pkb-categorize-key-list

(in-pr (pkb-categorize-key-list (pkb-list-keys (current-global-map))))

(let ((km (make-keymap)))
  (define-key km [?\M-\e] 'bind01)
  (define-key km [?a] 'bind02)
  (define-key km [?\C-a] 'bind03)
  (define-key km [?\C-q] 'bind04)
  (define-key km [?f] 'bind05)
  (define-key km [?g] 'bind06)
  (define-key km [?\M-7] 'bind07)
  (define-key km [?\M-9] 'bind08)
  (define-key km [(?1 . ?9)] 'bind09)
  (define-key km [?\[] 'bind10)
  (let* ((list-keys (pkb-list-keys km nil t))
	 (categorized-keys
	  (pkb-categorize-key-list list-keys 6 13 '(t t t))))
    (in-pr categorized-keys)
    ;; (in-pr-map 'map-char-table (nth 1 list-keys))
    )
)

(let ((km (make-keymap)))
  (define-key km [(?1 . ?9)] 'bind9)
  (let* ((list-keys (pkb-list-keys km nil t))
	 (categorized-keys
	  (pkb-categorize-key-list list-keys 0 13 '(t t t))))
    (in-pr categorized-keys)
    ;; (in-pr-map 'map-char-table (nth 1 list-keys))
    )
)

(let ((proc-list-keys
       (pkb-categorize-key-list (pkb-list-keys (current-global-map) nil t)
				7 13)))
  (in-pr proc-list-keys))

;;;; ************************************************
;; Generate lists for key-groups

(key-description (vector (aref "abc" 0)))

(defun explode-string (stringi)
  "Return a list where each character of STRINGI is an element."
  (let (char-list char-list-lc)
    (dotimes (i (length stringi))
      (add-to-end-of-list char-list (key-description (vector (aref stringi i))) char-list-lc))
    char-list)
)

(in-pr (explode-string "`1234567890-+"))
(?` ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?0 ?- ?+)

(in-pr (explode-string "~!@#$%^&*()_+"))
(?~ ?! ?@ ?# ?$ ?% ?^ ?& ?* ?( ?) ?_ ?+)

(in-pr (explode-string "qwertyuiop[]\\{}|"))
(?q ?w ?e ?r ?t ?y ?u ?i ?o ?p ?[ ?] ?\\ ?{ ?} ?|)

(in-pr (explode-string "asdfghjkl;':\""))
(?a ?s ?d ?f ?g ?h ?j ?k ?l ?\; ?' ?: ?\")

(in-pr (explode-string "zxcvbnm,./<>?"))
(?z ?x ?c ?v ?b ?n ?m ?, ?. ?/ ?< ?> ??)

;;;; ************************************************
;; Experiment with map-char-table oddity

(let ((ct (make-char-table 'keymap)) permev)
  (set-char-table-range ct '(1 . 2) 'binding)
  (map-char-table
   (lambda (event defn)
     (setq permev event)
     (insert (prin1-to-string permev)))
   ct)
  (insert (concat "\n" (prin1-to-string permev)))
  )
(1 . 2)
(3 . 4194303)

;;;; ************************************************
;; Test pkb-sort-pks-list

(in-pr (pkb-sort-pks-list
 '(
   ([] simple bks-w-bindings1)
   ([?b] simple ( (?w . binding3) (?\M-t . binding4)))
   ([?u] compact bks-w-bindings2)
   ([?\C-b] simple ( (?a . binding) (?q . binding2) ))
   ([?\C-\M-r] simple ( (?w . binding3) (?\M-t . binding4)))
   ([?t] simple ( (?w . binding3) (?\M-t . binding4)))
  )
 nil
))

(in-pr (pkb-sort-pks-list
 '(
   ([] simple ( (?q . binding1) (?\C-t . binding2)))
   ([?b] simple ( (?w . binding3) (?\M-t . binding4)))
   ([?q] compact compactbind)
  )
 nil
))

;;;; ************************************************
;; Understanding printing

(progn (print 'The\ cat\ in)
(print "the hat")
(print " came back"))

(in-pr (progn (prin1 'The\ cat\ in)
(prin1 "the hat")
(prin1 " came back")))

(progn
(princ 'The\ cat)
(princ " in the \"hat\""))

(print 'The\ cat\ in (current-buffer))

The\ cat\ in

(prin1 'The\ cat\ in (current-buffer))
The\ cat\ in
(princ 'The\ cat\ in (current-buffer))
The cat in
(print "the hat came back" (current-buffer))

"the hat came back"

(prin1 "the hat came back" (current-buffer))
"the hat came back"
(princ "the hat came back" (current-buffer))
the hat came back
(print " in the \"hat\"" (current-buffer))

" in the \"hat\""

(prin1 " in the \"hat\"" (current-buffer))
" in the \"hat\""
(princ " in the \"hat\"" (current-buffer))
 in the "hat"
end


;;;; ************************************************
;; Does deleting the current entry screw up dolist? (answer: no)

(let ((lst (list 1 2 3 4 5)))
  (dolist (elt lst)
    (insert (concat (prin1-to-string elt) ": " (prin1-to-string lst) "\n"))
    (when (eq elt 2)
      (setq lst (delq 2 lst))
      (insert
       (concat "After del - " (prin1-to-string elt) ": " (prin1-to-string lst)
	       "\n")))
    )
)

1: (1 2 3 4 5)
2: (1 2 3 4 5)
After del - 2: (1 3 4 5)
3: (1 3 4 5)
4: (1 3 4 5)
5: (1 3 4 5)

(let ((lst (list 1 2 3 4 5)))
  (dolist (elt lst)
    (insert (concat (prin1-to-string elt) ": " (prin1-to-string lst) "\n"))
    (when (eq elt 2)
      (setq lst (delq 3 lst))
      (insert
       (concat "After del - " (prin1-to-string elt) ": " (prin1-to-string lst)
	       "\n")))
    )
)
1: (1 2 3 4 5)
2: (1 2 3 4 5)
After del - 2: (1 2 4 5)
4: (1 2 4 5)
5: (1 2 4 5)

;;;; ************************************************
;; Understanding link between escape and 27 = ?\C-\[

(in-pr (key-description (vector (event-basic-type 27))))
"["

(in-pr (event-modifiers 27))
(control)

(in-pr (event-convert-list '(control 27)))
27

(in-pr (event-convert-list '(meta 27)))
134217755

(in-pr (key-description (vector (event-convert-list '(meta 27)))))
"M-ESC"

(in-pr (key-description (vector (event-convert-list '(alt 27)))))
"A-ESC"

(in-pr (key-description (vector (event-convert-list '(control ?\[)))))
"ESC"

(in-pr (key-description (vector (event-convert-list '(meta ?\[)))))
"M-["

(in-pr
 (key-description (vector (event-convert-list '(control meta ?\[)))))
"M-ESC"

(in-pr
 (key-description (vector (event-convert-list '(alt ?\[)))))
"A-["

(in-pr
 (key-description (vector (event-convert-list '(alt control ?\[)))))
"A-ESC"

(in-pr (lookup-key (current-global-map) [?\M-\e]))
(keymap (58 . eval-expression) (27 . keyboard-escape-quit))

(in-pr (key-description [58])) ":"

(describe-key [27 ?\H-\e]) (execute-kbd-macro [27 27 27])
(key-description [27 ?\H-\M-[]))

(in-pr (key-description (vector ?\C-\e)))
"C-ESC"

(in-pr (key-description (vector (event-basic-type ?\C-\e)))) "["
(in-pr (event-modifiers ?\C-\e)) (control)

(let ((km (make-keymap)))
  (define-key km [?\C-\e] 'bind)
  (in-pr km)
)
(keymap #^[nil nil keymap nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] (67108891 . bind))

(let ((km (make-keymap)))
  (define-key km [?\e] 'bind)
  (in-pr km)
)

(in-pr ?\M-\e)		134217755
(in-pr ?\C-\M-\[)	134217755
(describe-key [?\C-\e])

(describe-key [?\C-h ?k])
(describe-key [C-escape])
(in-pr (read-key-sequence "Sequence:")) [C-escape]
(in-pr (read-key-sequence "Sequence:")) "q"
(in-pr (read-key-sequence-vector "Sequence:")) [27 113]
(in-pr (read-key-sequence-vector "Sequence:")) [C-escape]
(in-pr (read-event)) escape
(in-pr (read-event)) C-escape
(in-pr (read-event)) M-escape
(in-pr (read-event)) 
(in-pr meta-prefix-char) 27
(in-pr (read-key)) 27
(in-pr (read-key)) C-escape
(in-pr (lookup-key (current-global-map) [C-escape])) electric-buffer-list

;;;; ************************************************
;; Key translation

(in-pr keyboard-translate-table) nil

(in-pr extra-keyboard-modifiers) 0

(in-pr input-decode-map)
(keymap (27 keymap (C-backspace) (C-delete)) (C-M-backspace) (C-M-delete) (M-backspace) (M-delete))

(in-pr local-function-key-map)
(keymap (C-tab . [134217737]) (8388721 . [134217737]) (s-tab . [134217737]) (backspace . [127]) (kp-delete . [4]) (delete . [4]) keymap (S-iso-lefttab . [backtab]) (iso-lefttab . [backtab]) (M-escape . [134217755]) (M-return . [134217741]) (M-clear . [134217740]) (M-linefeed . [134217738]) (M-tab . [134217737]) (M-delete . [134217855]) (M-backspace . [134217855]) keymap (escape . [27]) (return . [13]) (clear . [12]) (linefeed . [10]) (tab . [9]) (kp-equal . [61]) (kp-divide . [47]) (kp-decimal . [46]) (kp-subtract . [45]) (kp-separator . [44]) (kp-add . [43]) (kp-multiply . [42]) (kp-enter . [13]) (kp-tab . [9]) (kp-space . [32]) (kp-9 . [57]) (kp-8 . [56]) (kp-7 . [55]) (kp-6 . [54]) (kp-5 . [53]) (kp-4 . [52]) (kp-3 . [51]) (kp-2 . [50]) (kp-1 . [49]) (kp-0 . [48]) (24 keymap (64 keymap (99 . event-apply-control-modifier) (83 . event-apply-shift-modifier) (97 . event-apply-alt-modifier) (109 . event-apply-meta-modifier) (115 . event-apply-super-modifier) (104 . event-apply-hyper-modifier))) (0 . [67108896]) (C-S-kp-9 . [C-S-prior]) (C-S-kp-8 . [C-S-up]) (C-S-kp-7 . [C-S-home]) (C-S-kp-6 . [C-S-right]) (C-S-kp-4 . [C-S-left]) (C-S-kp-3 . [C-S-next]) (C-S-kp-2 . [C-S-down]) (C-S-kp-1 . [C-S-end]) (C-S-kp-prior . [C-S-prior]) (C-S-kp-up . [C-S-up]) (C-S-kp-home . [C-S-home]) (C-S-kp-right . [C-S-right]) (C-S-kp-left . [C-S-left]) (C-S-kp-next . [C-S-next]) (C-S-kp-down . [C-S-down]) (C-S-kp-end . [C-S-end]) (S-kp-prior . [S-prior]) (S-kp-up . [S-up]) (S-kp-home . [S-home]) (S-kp-right . [S-right]) (S-kp-left . [S-left]) (S-kp-next . [S-next]) (S-kp-down . [S-down]) (S-kp-end . [S-end]) (kp-delete . [127]) (delete . [127]) (backspace . [127]) (kp-insert . [insert]) (kp-begin . [begin]) (kp-end . [end]) (M-kp-next . [M-next]) (kp-next . [next]) (kp-prior . [prior]) (kp-down . [down]) (kp-right . [right]) (kp-up . [up]) (kp-left . [left]) (kp-home . [home]))

(in-pr function-key-map)
(keymap (escape . [27]) (return . [13]) (clear . [12]) (linefeed . [10]) (tab . [9]) (kp-equal . [61]) (kp-divide . [47]) (kp-decimal . [46]) (kp-subtract . [45]) (kp-separator . [44]) (kp-add . [43]) (kp-multiply . [42]) (kp-enter . [13]) (kp-tab . [9]) (kp-space . [32]) (kp-9 . [57]) (kp-8 . [56]) (kp-7 . [55]) (kp-6 . [54]) (kp-5 . [53]) (kp-4 . [52]) (kp-3 . [51]) (kp-2 . [50]) (kp-1 . [49]) (kp-0 . [48]) (24 keymap (64 keymap (99 . event-apply-control-modifier) (83 . event-apply-shift-modifier) (97 . event-apply-alt-modifier) (109 . event-apply-meta-modifier) (115 . event-apply-super-modifier) (104 . event-apply-hyper-modifier))) (0 . [67108896]) (C-S-kp-9 . [C-S-prior]) (C-S-kp-8 . [C-S-up]) (C-S-kp-7 . [C-S-home]) (C-S-kp-6 . [C-S-right]) (C-S-kp-4 . [C-S-left]) (C-S-kp-3 . [C-S-next]) (C-S-kp-2 . [C-S-down]) (C-S-kp-1 . [C-S-end]) (C-S-kp-prior . [C-S-prior]) (C-S-kp-up . [C-S-up]) (C-S-kp-home . [C-S-home]) (C-S-kp-right . [C-S-right]) (C-S-kp-left . [C-S-left]) (C-S-kp-next . [C-S-next]) (C-S-kp-down . [C-S-down]) (C-S-kp-end . [C-S-end]) (S-kp-prior . [S-prior]) (S-kp-up . [S-up]) (S-kp-home . [S-home]) (S-kp-right . [S-right]) (S-kp-left . [S-left]) (S-kp-next . [S-next]) (S-kp-down . [S-down]) (S-kp-end . [S-end]) (kp-delete . [127]) (delete . [127]) (backspace . [127]) (kp-insert . [insert]) (kp-begin . [begin]) (kp-end . [end]) (M-kp-next . [M-next]) (kp-next . [next]) (kp-prior . [prior]) (kp-down . [down]) (kp-right . [right]) (kp-up . [up]) (kp-left . [left]) (kp-home . [home]))

(in-pr key-translation-map)
(keymap (24 keymap (56 . iso-transl-ctl-x-8-map)))

;;;; ************************************************
;; Understanding how emacs parses basic-types

'escape
(lookup-key (current-global-map) [escape])
(fset 'abc
   [prior])
(execute-kbd-macro [escape escape escape])
(event-modifiers 'C-escape)
(event-basic-type 'C-escape)

(event-modifiers 'C-M-escape)
(event-basic-type 'C-M-escape)

(defun db-event-basic-type (event)
  "Return the basic type of the given event (all modifiers removed).
The value is a printing character (not upper case) or a symbol.
EVENT may be an event or an event type.  If EVENT is a symbol
that has never been used in an event that has been read as input
in the current Emacs session, then this function may return nil."
  (if (consp event)
      (setq event (car event)))
  (if (symbolp event)
      (car (get event 'event-symbol-elements))
    (let* (base uncontrolled)
      (setq base (logand event (1- ?\A-\^@)))
      (setq uncontrolled (if (< base 32) (logior base 64) base))
      ;; There are some numbers that are invalid characters and
      ;; cause `downcase' to get an error.
      (condition-case ()
	  (downcase uncontrolled)
	(error uncontrolled)))))

;;;; ************************************************
;; Test PKB-SPLIT-FULL-TO-GROUPS

(setq key-groups 
 '( ( ("full")
      (?` ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?0 ?- ?=)
      (?~ ?! ?@ ?# ?$ ?% ?^ ?& ?* ?( ?) ?_ ?+)
      (?q ?w ?e ?r ?t ?y ?u ?i ?o ?p ?[ ?] ?\\ ?{ ?} ?|)
      (?a ?s ?d ?f ?g ?h ?j ?k ?l ?\; ?' ?: ?\")
      (?z ?x ?c ?v ?b ?n ?m ?, ?. ?/ ?< ?> ??))
    ( ("LHS of notebook")
      (insert home prior next end))
  )
)

(let* ((list-keys (pkb-list-keys (current-global-map) nil t))
       (categorized-keys
	(pkb-categorize-key-list list-keys 6 13 t))
       (split-for-full
	(pkb-split-full-to-groups (cdr categorized-keys) key-groups))
       )
  (in-pr split-for-full)
  ;; (in-pr-map 'map-char-table (nth 1 list-keys))
  )

;;;; ************************************************
;; Understand string-match

(progn
  (let ((str "I go to the hi,p town"))
    (string-match "hi\\(.\\)p" str)
    ;; (match-string 0 str)
    (replace-match "go\\1to" nil nil str)
  )
)
forward-next
(progn
  (let ((str "f3"))
    (if (string-match     "\\(\\W\\|^\\)f\\([0-9].*\\)$" str)
    ;; (match-string 0 str)
	(replace-match
	  "\\1F\\2" nil nil str)
      "no match")
  )
)


(progn
  (let ((str "I go to the hi,p town"))
    (string-match "hi\\(.\\)p" str)
    ;; (match-string 0 str)
    (match-substitute-replacement "go\\1to" nil nil str)
  )
)

(progn
  (let ((str "I go to the hi,p town"))
    (string-match "hi.p" str)
    ;; (match-string 0 str)
  )
)

(defun test-fcn (fcn)
  (funcall fcn "abc")
)

(test-fcn (lambda (inp) (insert inp)))

;;;; ************************************************
;; making dolist-cons

(defmacro dolist-cons (spec &rest body)
  "Loop over a list.
Evaluate BODY with VAR bound to each cons from LIST, in turn.
Then evaluate RESULT to get return value, default nil.

\(fn (VAR LIST [RESULT]) BODY...)"
  (declare (indent 1) (debug ((symbolp form &optional form) body)))
  ;; It would be cleaner to create an uninterned symbol,
  ;; but that uses a lot more space when many functions in many files
  ;; use dolist.
  `(let ((,(car spec) ,(nth 1 spec)))
    (while ,(car spec)
      ,@body
      (setq ,(car spec) (cdr ,(car spec))))
    ,@(if (cdr (cdr spec))
	  `((setq ,(car spec) nil) ,@(cdr (cdr spec))))
    )
)

(in-pr (macroexpand '(dolist (var list result) body)))
(let ((--dolist-tail-- list) var)
  (while --dolist-tail--
    (setq var (car --dolist-tail--))
    body
    (setq --dolist-tail-- (cdr --dolist-tail--)))
  (setq var nil) result
)

(in-pr (macroexpand '(dolist-cons (var list result) body)))
(let ((var list))
  (while var
    body
    (setq var (cdr var)))
  (setq var nil)
  result
)

(in-pr (macroexpand '(dolist-cons (var list) body)))
(let ((var list))
  (while var
    body
    (setq var (cdr var))))

;; ************************************************
;; Diagnose issue with SPC and DEL

(in-pr (key-description (kbd "M-SPC")))
"M-SPC"

(in-pr (event-basic-type (aref (kbd "M-SPC")0 )))
32

(in-pr (event-description (event-basic-type (aref (kbd "M-SPC")0 ))))
"SPC"

(in-pr (key-description (kbd "SPC")))
"SPC"

(in-pr (event-basic-type (aref (kbd "SPC")0 )))
32

(in-pr (pkb-list-keys (lookup-key (current-global-map) [f1])))

(in-pr-map 'map-char-table (nth 1 (pkb-list-keys (lookup-key (current-global-map) [f1]))))

(in-pr (pkb-categorize-key-list (pkb-list-keys (lookup-key (current-global-map) [f1])) 4 12))

(in-pr (pkb-split-full-to-groups (cdr (pkb-categorize-key-list (pkb-list-keys (lookup-key (current-global-map) [f1])) 4 12)) pkb-key-groups))

;; ************************************************
;; understanding event-modifiers and integer events < 127

(progn
  (insert "( ")
  (dotimes (i 128)
    (insert (if (= (mod i 6) 0) "\n " "")
	    "(" (number-to-string i) ": "
	    (prin1-to-string (event-description i)) ") "))
  (insert ") ")
)
( 
 (0: "C-@") (1: "C-a") (2: "C-b") (3: "C-c") (4: "C-d") (5: "C-e") 
 (6: "C-f") (7: "C-g") (8: "C-h") (9: "TAB") (10: "C-j") (11: "C-k") 
 (12: "C-l") (13: "RET") (14: "C-n") (15: "C-o") (16: "C-p") (17: "C-q") 
 (18: "C-r") (19: "C-s") (20: "C-t") (21: "C-u") (22: "C-v") (23: "C-w") 
 (24: "C-x") (25: "C-y") (26: "C-z") (27: "ESC") (28: "C-\\") (29: "C-]") 
 (30: "C-^") (31: "C-_") (32: "SPC") (33: "!") (34: "\"") (35: "#") 
 (36: "$") (37: "%") (38: "&") (39: "'") (40: "(") (41: ")") 
 (42: "*") (43: "+") (44: ",") (45: "-") (46: ".") (47: "/") 
 (48: "0") (49: "1") (50: "2") (51: "3") (52: "4") (53: "5") 
 (54: "6") (55: "7") (56: "8") (57: "9") (58: ":") (59: ";") 
 (60: "<") (61: "=") (62: ">") (63: "?") (64: "@") (65: "A") 
 (66: "B") (67: "C") (68: "D") (69: "E") (70: "F") (71: "G") 
 (72: "H") (73: "I") (74: "J") (75: "K") (76: "L") (77: "M") 
 (78: "N") (79: "O") (80: "P") (81: "Q") (82: "R") (83: "S") 
 (84: "T") (85: "U") (86: "V") (87: "W") (88: "X") (89: "Y") 
 (90: "Z") (91: "[") (92: "\\") (93: "]") (94: "^") (95: "_") 
 (96: "`") (97: "a") (98: "b") (99: "c") (100: "d") (101: "e") 
 (102: "f") (103: "g") (104: "h") (105: "i") (106: "j") (107: "k") 
 (108: "l") (109: "m") (110: "n") (111: "o") (112: "p") (113: "q") 
 (114: "r") (115: "s") (116: "t") (117: "u") (118: "v") (119: "w") 
 (120: "x") (121: "y") (122: "z") (123: "{") (124: "|") (125: "}") 
 (126: "~") (127: "DEL") )  

(progn
  (insert "( ")
  (dotimes (i 128)
    (insert "(" (number-to-string i) ": "
	    (number-to-string (event-basic-type i)) ")\n"))
  (insert ") ")
)
( (0: 64)
(1: 97)
(2: 98)
(3: 99)
(4: 100)
(5: 101)
(6: 102)
(7: 103)
(8: 104)
(9: 105)
(10: 106)
(11: 107)
(12: 108)
(13: 109)
(14: 110)
(15: 111)
(16: 112)
(17: 113)
(18: 114)
(19: 115)
(20: 116)
(21: 117)
(22: 118)
(23: 119)
(24: 120)
(25: 121)
(26: 122)
(27: 91)
(28: 92)
(29: 93)
(30: 94)
(31: 95)
(32: 32)
(33: 33)
(34: 34)
(35: 35)
(36: 36)
(37: 37)
(38: 38)
(39: 39)
(40: 40)
(41: 41)
(42: 42)
(43: 43)
(44: 44)
(45: 45)
(46: 46)
(47: 47)
(48: 48)
(49: 49)
(50: 50)
(51: 51)
(52: 52)
(53: 53)
(54: 54)
(55: 55)
(56: 56)
(57: 57)
(58: 58)
(59: 59)
(60: 60)
(61: 61)
(62: 62)
(63: 63)
(64: 64)
(65: 97)
(66: 98)
(67: 99)
(68: 100)
(69: 101)
(70: 102)
(71: 103)
(72: 104)
(73: 105)
(74: 106)
(75: 107)
(76: 108)
(77: 109)
(78: 110)
(79: 111)
(80: 112)
(81: 113)
(82: 114)
(83: 115)
(84: 116)
(85: 117)
(86: 118)
(87: 119)
(88: 120)
(89: 121)
(90: 122)
(91: 91)
(92: 92)
(93: 93)
(94: 94)
(95: 95)
(96: 96)
(97: 97)
(98: 98)
(99: 99)
(100: 100)
(101: 101)
(102: 102)
(103: 103)
(104: 104)
(105: 105)
(106: 106)
(107: 107)
(108: 108)
(109: 109)
(110: 110)
(111: 111)
(112: 112)
(113: 113)
(114: 114)
(115: 115)
(116: 116)
(117: 117)
(118: 118)
(119: 119)
(120: 120)
(121: 121)
(122: 122)
(123: 123)
(124: 124)
(125: 125)
(126: 126)
(127: 127)
)  

(progn
  (insert "( ")
  (dotimes (i 128)
    (let (match)
      (setq match
	    (catch 'result
	      (dotimes (j i)
		(when (and (equal (event-basic-type i) (event-basic-type j))
			   (< j i))
		  (throw 'result j)))
	      nil))
      (when match
	(insert "  (" (number-to-string i) ": " (number-to-string match)
		")\n"))))
  (insert ") ")
)
(   (64: 0)
  (65: 1)
  (66: 2)
  (67: 3)
  (68: 4)
  (69: 5)
  (70: 6)
  (71: 7)
  (72: 8)
  (73: 9)
  (74: 10)
  (75: 11)
  (76: 12)
  (77: 13)
  (78: 14)
  (79: 15)
  (80: 16)
  (81: 17)
  (82: 18)
  (83: 19)
  (84: 20)
  (85: 21)
  (86: 22)
  (87: 23)
  (88: 24)
  (89: 25)
  (90: 26)
  (91: 27)
  (92: 28)
  (93: 29)
  (94: 30)
  (95: 31)
  (97: 1)
  (98: 2)
  (99: 3)
  (100: 4)
  (101: 5)
  (102: 6)
  (103: 7)
  (104: 8)
  (105: 9)
  (106: 10)
  (107: 11)
  (108: 12)
  (109: 13)
  (110: 14)
  (111: 15)
  (112: 16)
  (113: 17)
  (114: 18)
  (115: 19)
  (116: 20)
  (117: 21)
  (118: 22)
  (119: 23)
  (120: 24)
  (121: 25)
  (122: 26)
) 

(progn
  (insert "( ")
  (dotimes (i 128)
    (let (match-list)
    (dotimes (j 128)
      (when (equal i (event-basic-type j))
	(add-to-list 'match-list j t)))
    (when match-list
      (insert "  (" (number-to-string i) ": ")
      (dolist (match match-list)
	(insert (number-to-string match) " "))
      (insert ")\n"))))
  (insert ") ")
)
;; C-bk, S-bk is an integer if 97-122
;; C-bk is an integer if 64, 91-95, 97-122
(   (32: 32 )
    (33: 33 )
    (34: 34 )
    (35: 35 )
    (36: 36 )
    (37: 37 )
    (38: 38 )
    (39: 39 )
    (40: 40 )
    (41: 41 )
    (42: 42 )
    (43: 43 )
    (44: 44 )
    (45: 45 )
    (46: 46 )
    (47: 47 )
    (48: 48 )
    (49: 49 )
    (50: 50 )
    (51: 51 )
    (52: 52 )
    (53: 53 )
    (54: 54 )
    (55: 55 )
    (56: 56 )
    (57: 57 )
    (58: 58 )
    (59: 59 )
    (60: 60 )
    (61: 61 )
    (62: 62 )
    (63: 63 )
    (64: 0 64 )
    (91: 27 91 )
    (92: 28 92 )
    (93: 29 93 )
    (94: 30 94 )
    (95: 31 95 )
    (96: 96 )
    (97: 1 65 97 )
    (98: 2 66 98 )
    (99: 3 67 99 )
    (100: 4 68 100 )
    (101: 5 69 101 )
    (102: 6 70 102 )
    (103: 7 71 103 )
    (104: 8 72 104 )
    (105: 9 73 105 )
    (106: 10 74 106 )
    (107: 11 75 107 )
    (108: 12 76 108 )
    (109: 13 77 109 )
    (110: 14 78 110 )
    (111: 15 79 111 )
    (112: 16 80 112 )
    (113: 17 81 113 )
    (114: 18 82 114 )
    (115: 19 83 115 )
    (116: 20 84 116 )
    (117: 21 85 117 )
    (118: 22 86 118 )
    (119: 23 87 119 )
    (120: 24 88 120 )
    (121: 25 89 121 )
    (122: 26 90 122 )
    (123: 123 )
    (124: 124 )
    (125: 125 )
    (126: 126 )
    (127: 127 )
    )

;; ************************************************
;; what does accessible-keymaps do if there are two ways to reach keymap

(let ((km1 (make-sparse-keymap))
      (km2 (make-sparse-keymap)))
  (define-key km1 [?a] km2)
  (define-key km1 [?b] km2)
  (define-key km1 [?c] 'a)
  (in-pr (accessible-keymaps km1))
)

(([] keymap (99 . a) (98 . #1=(keymap)) (97 . #1#))
 ([98] . #1#)
 ([97] . #1#))

;; ************************************************

(let ((item ?\C-\M-k))
  (substring (prin1-to-string (event-convert-list
			       (append (event-modifiers item) '(abc)))) 0 -3)
)

(let ((test-km (make-keymap)))
  (define-key test-km [?\M-\C-5] 'abc)
  (define-key test-km [?\M-\C-5] 'cde)
  (in-pr test-km))
(mapconcat 'identity '("hi" "bye") " ")

(mapconcat 'identity nil " ")

(setq str "ght")
(string-match "abc" 

(pkb-html-save-keymap (current-global-map) "~/test.html")