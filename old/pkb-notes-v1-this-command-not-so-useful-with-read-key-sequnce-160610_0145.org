* from A

** investigate how keys are resolved

*** print events
(let ((formatting "| %20s | %20s | %20s |\n"))
  (insert "(\n")
  (insert (format formatting "event [raw] " "basic type [raw] " "modifiers "))
  (insert
   (let ((tsfm-formatting (format formatting "-" "-" "-")))
     (setf tsfm-formatting (replace-regexp-in-string " " "-" tsfm-formatting))
     (setf tsfm-formatting (replace-regexp-in-string "|" "+" tsfm-formatting))
     (setf (elt tsfm-formatting 0) ?|)
     (setf (elt tsfm-formatting (- (length tsfm-formatting) 2)) ?|)
     tsfm-formatting))
  (unwind-protect
    (while t (let ((event (read-event "Generate event:")))
	       (insert
		(format formatting
			;; event
			(concat (key-description (vector event)) " ["
				(prin1-to-string event) "]")
			;; basic type
			(let ((basic-type (event-basic-type event)))
			  (concat
			   (key-description (vector basic-type)) " ["
			   (prin1-to-string basic-type) "]"))
			;; event-modifiers
			(event-modifiers event)
			))))
    (insert ")\n")))
(
|         event [raw]  |    basic type [raw]  |           modifiers  |
|----------------------+----------------------+----------------------|
|              f [102] |              f [102] |                  nil |
|              j [106] |              j [106] |                  nil |
|               D [68] |              d [100] |              (shift) |
|    <return> [return] |    <return> [return] |                  nil |
|    <M-S-f4> [M-S-f4] |            <f4> [f4] |         (meta shift) |
|             C-l [12] |              l [108] |            (control) |
| <C-M-backspace> [C-M-backspace] | <backspace> [backspace] |       (meta control) |
)

*** what keys are included?

(let ((formatting "| %20s | %20s | %20s |\n"))
  (insert "(\n")
  (insert (format formatting "event " " include base key? " " include event?"))
  (insert
   (let ((tsfm-formatting (format formatting "-" "-" "-")))
     (setf tsfm-formatting (replace-regexp-in-string " " "-" tsfm-formatting))
     (setf tsfm-formatting (replace-regexp-in-string "|" "+" tsfm-formatting))
     (setf (elt tsfm-formatting 0) ?|)
     (setf (elt tsfm-formatting (- (length tsfm-formatting) 2)) ?|)
     tsfm-formatting))
  (unwind-protect
      (while t (let ((event (read-event "Press key:")))
		 (insert
		  (format formatting
			  ;; event
			  (key-description (vector event))
			  ;; basic type
			  (not (null (or
				      (and (integerp event) (>= event 0) (< event 128))
				      (member event pkb-include-base-key-list))))
			  (pkb-include-mk-p event)))))
    (insert ")\n")))

(
|               event  |   include base key?  |       include event? |
|----------------------+----------------------+----------------------|
|                    s |                    t |                    t |
|                    d |                    t |                    t |
|        <C-backspace> |                  nil |                    t |
|          <backspace> |                    t |                    t |
|             <escape> |                    t |                    t |
|               <M-f1> |                  nil |                    t |
|             <M-S-f5> |                  nil |                    t |
|              <prior> |                    t |                    t |
|               <next> |                    t |                    t |
)

* useful commands

** understanding keymaps

*** lookup-key

(lookup-key KEYMAP KEY &optional ACCEPT-DEFAULT)

In keymap KEYMAP, look up key sequence KEY.  Return the definition.
A value of nil means undefined.  See doc of `define-key'
for kinds of definitions.

A number as value means KEY is "too long";
that is, characters or symbols in it except for the last one
fail to be a valid sequence of prefix characters in KEYMAP.
The number is how many characters at the front of KEY
it takes to reach a non-prefix key.

Normally, `lookup-key' ignores bindings for t, which act as default
bindings, used when nothing else in the keymap applies; this makes it
usable as a general function for probing keymaps.  However, if the
third optional argument ACCEPT-DEFAULT is non-nil, `lookup-key' will
recognize the default bindings, just as `read-key-sequence' does.

** determining keys pressed: this-...

*** examples
**** this-single-... comands using `read-event'

We don't include this-command-keys/this-command-keys-vector because these commands 

(let* (begin-mark end-mark (formatting "| %12s | %12s | %12s | %12s |\n")
		  row-group-divider)
  ;; make ROW-GROUP-DIVIDER
  (setf row-group-divider (format formatting "-" "-" "-" "-"))
  (setf row-group-divider (replace-regexp-in-string " " "-" row-group-divider))
  (setf row-group-divider (replace-regexp-in-string "|" "+" row-group-divider))
  (setf (elt row-group-divider 0) ?|)
  (setf (elt row-group-divider (- (length row-group-divider) 2)) ?|)

  (insert "(\n")
  (setq begin-mark (point-marker))
  (insert (format formatting "key" "this-single"
		  "this-single" "this-command"))  
  (insert (format formatting "-sequence" "-command-raw-keys"
		  "-command-keys" "-keys-vector"))  
  (unwind-protect
      (let (seq)
	(while (not (equal seq [?q]))
	;; (clear-this-command-keys t)
	(setq seq (read-key-sequence-vector "Generate key-sequence (quit with \"q\"):" nil t))
	(insert row-group-divider)	
	(insert
	 (format formatting
		 (key-description seq)
		 (key-description (this-single-command-raw-keys))
		 (key-description (this-single-command-keys))
		 (key-description (this-command-keys-vector))))
	(insert
	 (format formatting
		 (prin1-to-string seq)
		 (prin1-to-string (this-single-command-raw-keys))
		 (prin1-to-string (this-single-command-keys))
		 (prin1-to-string (this-command-keys-vector))))	)
	(setq end-mark (point-marker))
	(org-table-align)
	(goto-char (marker-position end-mark)))
    (insert ")\n")))
(
| key        | this-single       | this-single   | this-command |
| -sequence  | -command-raw-keys | -command-keys | -keys-vector |
|------------+-------------------+---------------+--------------|
| C--        | C--               | C--           | C--          |
| [67108909] | [67108909]        | [67108909]    | [67108909]   |
|------------+-------------------+---------------+--------------|
| w          | w                 | w             | w            |
| [119]      | [119]             | [119]         | [119]        |
|------------+-------------------+---------------+--------------|
| q          | q                 | q             | q            |
| [113]      | [113]             | [113]         | [113]        |
)
(
| key       | this-single       | this-single   | this-command |
| -sequence | -command-raw-keys | -command-keys | -keys-vector |
|-----------+-------------------+---------------+--------------|
| C-c c     | C-c c             | C-c c         | C-c c        |
| [3 99]    | [3 99]            | [3 99]        | [3 99]       |
|-----------+-------------------+---------------+--------------|
| C-u       | C-u               | C-u           | C-u          |
| [21]      | [21]              | [21]          | [21]         |
|-----------+-------------------+---------------+--------------|
| C-c c     | C-c c             | C-c c         | C-c c        |
| [3 99]    | [3 99]            | [3 99]        | [3 99]       |
|-----------+-------------------+---------------+--------------|
| q         | q                 | q             | q            |
| [113]     | [113]             | [113]         | [113]        |
)
(this-single-command-raw-keys)[24 5]
(this-single-command-keys)[24 5][24 5]

(defun dothis () (interactive) (in-pr (this-command-keys-vector)))
(local-set-key [?q] 'dothis)[113][21 113][67108909 113][67108909 67108914 67108914 113]

(
| key        | this-single       | this-single   | this-command |
| -sequence  | -command-raw-keys | -command-keys | -keys-vector |
|------------+-------------------+---------------+--------------|
| SPC        | SPC               | SPC           | SPC          |
| [32]       | [32]              | [32]          | [32]         |
|------------+-------------------+---------------+--------------|
| C-u        | C-u               | C-u           | C-u          |
| [21]       | [21]              | [21]          | [21]         |
|------------+-------------------+---------------+--------------|
| C-1        | C-1               | C-1           | C-1          |
| [67108913] | [67108913]        | [67108913]    | [67108913]   |
|------------+-------------------+---------------+--------------|
| C-3        | C-3               | C-3           | C-3          |
| [67108915] | [67108915]        | [67108915]    | [67108915]   |
|------------+-------------------+---------------+--------------|
| q          | q                 | q             | q            |
| [113]      | [113]             | [113]         | [113]        |
)

(
| key                    | this-single                | this-single            | this-command           |
| -sequence              | -command-raw-keys          | -command-keys          | -keys-vector           |
|------------------------+----------------------------+------------------------+------------------------|
| SPC                    | SPC                        | SPC                    | SPC                    |
| [32]                   | [32]                       | [32]                   | [32]                   |
|------------------------+----------------------------+------------------------+------------------------|
| <down-mouse-1>         | <down-mouse-1>             | <down-mouse-1>         | <down-mouse-1>         |
| [(down-mouse-1 (...))] | [(down-mouse-1 (...))]     | [(down-mouse-1 (...))] | [(down-mouse-1 (...))] |
|------------------------+----------------------------+------------------------+------------------------|
| <mouse-1>              | <mouse-1>                  | <mouse-1>              | <mouse-1>              |
| [(mouse-1 (...))]      | [(mouse-1 (...))]          | [(mouse-1 (...))]      | [(mouse-1 (...))]      |
|------------------------+----------------------------+------------------------+------------------------|
| <left>                 | <left>                     | <left>                 | <left>                 |
| [left]                 | [left]                     | [left]                 | [left]                 |
|------------------------+----------------------------+------------------------+------------------------|
| C-c c                  | C-c c                      | C-c c                  | C-c c                  |
| [3 99]                 | [3 99]                     | [3 99]                 | [3 99]                 |
|------------------------+----------------------------+------------------------+------------------------|
| C-x q                  | C-x q                      | C-x q                  | C-x q                  |
| [24 113]               | [24 113]                   | [24 113]               | [24 113]               |
|------------------------+----------------------------+------------------------+------------------------|
| ESC ESC ESC            | <escape> <escape> <escape> | ESC ESC ESC            | ESC ESC ESC            |
| [27 27 27]             | [escape escape escape]     | [27 27 27]             | [27 27 27]             |
|------------------------+----------------------------+------------------------+------------------------|
| M-w                    | M-w                        | M-w                    | M-w                    |
| [134217847]            | [134217847]                | [134217847]            | [134217847]            |
)


**** this-... comands using `read-key-sequence-vector'
(let (begin-mark end-mark (formatting "| %12s | %12s | %12s | %12s |\n")
		 row-group-divider)
  (setf row-group-divider (format formatting "-" "-" "-" "-"))
  (setf row-group-divider (replace-regexp-in-string " " "-" row-group-divider))
  (setf row-group-divider (replace-regexp-in-string "|" "+" row-group-divider))
  (setf (elt row-group-divider 0) ?|)
  (setf (elt row-group-divider (- (length row-group-divider) 2)) ?|)

  (insert "(\n")
  (setq begin-mark (point-marker))
  (insert (format formatting "" "this-single" "this-single" "this-command"))
  (insert (format formatting "event" "-command-raw-keys" "-command-keys" "-keys-vector"))
  (insert row-group-divider)
  (unwind-protect
      (let (event)
	(while (not (equal event ?q))
	(clear-this-command-keys t)
	(setq event (read-event "Generate event (quit on \"q\" or \"C-g\"):"))
	(insert
	 (format formatting
		 (concat
		  (key-description (vector event)) " " (prin1-to-string (vector event)))
		 (concat
		  (key-description (this-single-command-raw-keys))
		  " " (prin1-to-string (this-single-command-raw-keys)))
		 (concat
		  (key-description (this-single-command-keys))
		  " " (prin1-to-string (this-single-command-keys)))
		 (concat
		  (key-description (this-command-keys-vector))
		  " " (prin1-to-string (this-command-keys-vector))))))
	(setq end-mark (point-marker))
	(org-table-align)
	(goto-char (marker-position end-mark)))
    (insert ")\n")))

(
|                   | this-single       | this-single       | this-command      |
| event             | -command-raw-keys | -command-keys     | -keys-vector      |
|-------------------+-------------------+-------------------+-------------------|
| SPC [32]          | C-x C-e [24 5]    | SPC [32]          | SPC [32]          |
| C-c [3]           | C-x C-e [24 5]    | C-c [3]           | C-c [3]           |
| <escape> [escape] | C-x C-e [24 5]    | <escape> [escape] | <escape> [escape] |
| M-q [134217841]   | C-x C-e [24 5]    | M-q [134217841]   | M-q [134217841]   |
| M-w [134217847]   | C-x C-e [24 5]    | M-w [134217847]   | M-w [134217847]   |
| M-m [134217837]   | C-x C-e [24 5]    | M-m [134217837]   | M-m [134217837]   |
| C-j [10]          | C-x C-e [24 5]    | C-j [10]          | C-j [10]          |
| q [113]           | C-x C-e [24 5]    | q [113]           | q [113]           |
)




*** this-single-command-raw-keys
(this-single-command-raw-keys)

Return the raw events that were read for this command.
More generally, it returns the last key sequence read, either by the command loop or
by `read-key-sequence'.
Unlike `this-single-command-keys', this function's value shows the events before all
translations (except for input methods).
The value is always a vector.

*** this-single-command-keys
(this-single-command-keys)

Return the key sequence that invoked this command.
More generally, it returns the last key sequence read, either by the command loop or
by `read-key-sequence'.
Unlike `this-command-keys', this function's value does not include prefix arguments.
The value is always a vector.

*** this-command-keys
(this-command-keys)

This function returns a string or vector containing the key sequence that invoked the
present command, plus any previous commands that generated the prefix argument for
this command. Any events read by the command using read-event without a timeout get
tacked on to the end.

However, if the command has called read-key-sequence, it returns the last read key
sequence. The value is a string if all events in the sequence were characters that
fit in a string.

*** this-command-keys-vector

(this-command-keys-vector)

Like `this-command-keys', except that it always returns the events in a vector, so
you don’t need to deal with the complexities of storing input events in a string.

*** clear-this-command-keys

(clear-this-command-keys &optional KEEP-RECORD)

Clear out the vector that `this-command-keys' returns.
Also clear the record of the last 100 events, unless optional arg
KEEP-RECORD is non-nil.

*** discard-input

(discard-input)

Discard the contents of the terminal input buffer.
Also end any kbd macro being defined.

*** read-key-sequence

(read-key-sequence PROMPT &optional CONTINUE-ECHO DONT-DOWNCASE-LAST
CAN-RETURN-SWITCH-FRAME CMD-LOOP)

Read a sequence of keystrokes and return as a string or vector.
The sequence is sufficient to specify a non-prefix command in the current local and global maps.

First arg PROMPT is a prompt string.  If nil, do not prompt specially.
Second (optional) arg CONTINUE-ECHO, if non-nil, means this key echos as a continuation of the previous key.

The third (optional) arg DONT-DOWNCASE-LAST, if non-nil, means do not convert the last event to lower case.  (Normally any upper case event is converted to lower case if the original event is undefined and the lower case equivalent is defined.)  A non-nil value is appropriate for reading a key sequence to be defined.

A C-g typed while in this function is treated like any other character, and `quit-flag' is not set.

If the key sequence starts with a mouse click, then the sequence is read using the keymaps of the buffer of the window clicked in, not the buffer of the selected window as normal.

`read-key-sequence' drops unbound button-down events, since you normally only care about the click or drag events which follow them.  If a drag or multi-click event is unbound, but the corresponding click event would be bound, `read-key-sequence' turns the event into a click event at the drag's starting position.  This means that you don't have to distinguish between click and drag, double, or triple events unless you want to.

`read-key-sequence' prefixes mouse events on mode lines, the vertical lines separating windows, and scroll bars with imaginary keys `mode-line', `vertical-line', and `vertical-scroll-bar'.

Optional fourth argument CAN-RETURN-SWITCH-FRAME non-nil means that this function will process a switch-frame event if the user switches frames before typing anything.  If the user switches frames in the middle of a key sequence, or at the start of the sequence but CAN-RETURN-SWITCH-FRAME is nil, then the event will be put off until after the current key sequence.

`read-key-sequence' checks `function-key-map' for function key sequences, where they wouldn't conflict with ordinary bindings.  See `function-key-map' for more details.

The optional fifth argument CMD-LOOP, if non-nil, means that this key sequence is being read by something that will read commands one after another.  It should be nil if the caller will read just one key sequence.

*** read-event

(read-event &optional PROMPT INHERIT-INPUT-METHOD SECONDS)

Read an event object from the input stream.
If the optional argument PROMPT is non-nil, display that as a prompt.
If the optional argument INHERIT-INPUT-METHOD is non-nil and some input method is turned on in the current buffer, that input method is used for reading a character.
If the optional argument SECONDS is non-nil, it should be a number specifying the maximum number of seconds to wait for input.  If no input arrives in that time, return nil.  SECONDS may be a floating-point value.

*** read-key

(read-key &optional PROMPT)

Read a key from the keyboard.
Contrary to `read-event' this will not return a raw event but instead will obey the input decoding and translations usually done by `read-key-sequence'. So escape sequences and keyboard encoding are taken into account.
When there's an ambiguity because the key looks like the prefix of some sort of escape sequence, the ambiguity is resolved via `read-key-delay'.

*** quit-flag (variable)

Non-nil causes `eval' to abort, unless `inhibit-quit' is non-nil.
If the value is t, that means do an ordinary quit.
If the value equals `throw-on-input', that means quit by throwing to the tag specified in `throw-on-input'; it's for handling `while-no-input'.
Typing C-g sets `quit-flag' to t, regardless of `inhibit-quit', but `inhibit-quit' non-nil prevents anything from taking notice of that.

*** inhibit-quit (variable)

Non-nil inhibits C-g quitting from happening immediately.
Note that `quit-flag' will still be set by typing C-g, so a quit will be signaled as soon as `inhibit-quit' is nil. To prevent this happening, set `quit-flag' to nil before making `inhibit-quit' nil.

*** function-key-map (variable)

The parent keymap of all `local-function-key-map' instances.
Function key definitions that apply to all terminal devices should go here.  If a mapping is defined in both the current `local-function-key-map' binding and this variable, then the local definition will take precedence.

*** local-function-key-map (variable)

Keymap that translates key sequences to key sequences during input. This is used mainly for mapping key sequences into some preferred key events (symbols).

The `read-key-sequence' function replaces any subsequence bound by `local-function-key-map' with its binding.  More precisely, when the active keymaps have no binding for the current key sequence but `local-function-key-map' binds a suffix of the sequence to a vector or string, `read-key-sequence' replaces the matching suffix with its binding, and continues with the new sequence.

If the binding is a function, it is called with one argument (the prompt) and its return value (a key sequence) is used.

The events that come from bindings in `local-function-key-map' are not themselves looked up in `local-function-key-map'.

For example, suppose `local-function-key-map' binds `ESC O P' to [f1]. Typing `ESC O P' to `read-key-sequence' would return [f1].  Typing `C-x ESC O P' would return [?\C-x f1].  If [f1] were a prefix key, typing `ESC O P x' would return [f1 x].

`local-function-key-map' has a separate binding for each terminal device.  See Info node `(elisp)Multiple Terminals'.  If you need to define a binding on all terminals, change `function-key-map' instead.  Initially, `local-function-key-map' is an empty keymap that has `function-key-map' as its parent on all terminal devices.

*** last-input-event (variable)

(last-input-event) 

This variable records the last terminal input event read, whether as part of a command or explicitly by a Lisp program.

*** command-history (variable)

List of recent commands that read arguments from terminal. Each command is represented as a form to evaluate.

Maximum length of the history list is determined by the value of `history-length', which see.


*** this-command-keys-shift-translated (variable)

Non-nil if the key sequence activating this command was shift-translated.
Shift-translation occurs when there is no binding for the key sequence as entered,
but a binding was found by changing an upper-case letter to lower-case, or a shifted
function key to an unshifted one.

*** extra-keyboard-modifiers

A mask of additional modifier keys to use with every keyboard character.
Emacs applies the modifiers of the character stored here to each keyboard character
it reads.  For example, after evaluating the expression
    (setq extra-keyboard-modifiers ?\C-x)
all input characters will have the control modifier applied to them.

Note that the character ?\C-@, equivalent to the integer zero, does not count as a
control character; rather, it counts as a character with no modifiers; thus, setting
`extra-keyboard-modifiers' to zero cancels any modification.

*** keyboard-translate-table (variable)

Translate table for local keyboard input, or nil.
If non-nil, the value should be a char-table.  Each character read from the keyboard
is looked up in this char-table.  If the value found there is non-nil, then it is
used instead of the actual input character.

The value can also be a string or vector, but this is considered obsolete. If it is a
string or vector of length N, character codes N and up are left untranslated.  In a
vector, an element which is nil means "no translation".

This is applied to the characters supplied to input methods, not their output.  See
also `translation-table-for-input'.

This variable has a separate binding for each terminal.
See Info node `(elisp)Multiple Terminals'.

*** unread-command-events (variable)

List of events to be read as the command input.
These events are processed first, before actual keyboard input.
Events read from this list are not normally added to `this-command-keys', as they
will already have been added once as they were read for the first time.
An element of the form (t . EVENT) forces EVENT to be added to that list.

*** last-command (variable)

The last command executed.
Normally a symbol with a function definition, but can be whatever was found in the
keymap, or whatever the variable `this-command' was set to by that command.

The value `mode-exit' is special; it means that the previous command read an event
that told it to exit, and it did so and unread that event. In other words, the
present command is the event that made the previous command exit.

The value `kill-region' is special; it means that the previous command was a kill
command.

`last-command' has a separate binding for each terminal device.
See Info node `(elisp)Multiple Terminals'.

*** real-last-command (variable)

Same as `last-command', but never altered by Lisp code.
Taken from the previous value of `real-this-command'.

*** last-repeatable-command (variable)

Last command that may be repeated.
The last command executed that was not bound to an input event.
This is the command `repeat' will try to repeat.
Taken from a previous value of `real-this-command'.

*** last-nonmenu-event (variable)

This variable holds the last input event read as part of a key sequence, not counting
events resulting from mouse menus.

*** last-command-event (variable)

This variable is set to the last input event that was read by the command loop as
part of a command. The principal use of this variable is in self-insert-command,
which uses it to decide which character to insert.

*** recent-keys

(recent-keys)

Return vector of last 300 events, not counting those from keyboard macros.

*** listify-key-sequence

(listify-key-sequence KEY)

This function converts the string or vector KEY to a list of individual events, which
you can put in `unread-command-events'.

**** test
(cl-dolist (key '([134217847] [27 119] "w")) 
     (insert (concat (key-description key) ": "))
     (in-pr (listify-key-sequence key))
     (insert "\n"))
M-w: (134217847)
M-w: (27 119)
M-w: (27 119)

[JN: Not so useful]

** note

From elisp.pdf 
"The editor command loop reads key sequences using the function `read-key-sequence',
which uses `read-event'"

* more

read-key-sequence
this-single-command-raw-keys
(progn
  (read-key)
  (in-pr (pkb-include-mk-p (aref (this-single-command-raw-keys) 0))))


(progn
  (read-key)
  (pkb-include-mk-p (aref (this-single-command-raw-keys) 0)))


[51]
[escape]

(let (tmplst)
  (dolist (a '("1" "2" "3"))
    (dolist (b '("4" "5" "6"))
      (add-to-list 'tmplst (concat a " " b) t)))
  tmplst)

(setq alisttmp '((a 1) (b 2)))
(setq alistb alisttmp)
(add-to-list 'alisttmp '(c 4))
(set (assoc 'a alisttmp) '(a 3))

(lookup-key global-map (read-kbd-macro "C-c"))
(lookup-key global-map (read-kbd-macro "ESC"))
(symbol-function 'mode-specific-command-prefix)
(in-pr (symbol-function 'ESC-prefix))

* from B

;;;; ************************************************
;; Print members of `current-global-map' for which `pkb-include-mk-p' returns nil (and which aren't members of IGNORE-EVENT or undefined)
#+BEGIN_SRC emacs-lisp
(let ((ignore-event '(menu-bar tool-bar)))
  (insert "(")
  (map-keymap 
   (lambda (event defn)
     (unless (or (null defn)
		 (memq event ignore-event)
		 (pkb-include-mk-p event))
       (insert (concat "(" (prin1-to-string event) ": "
		       (prin1-to-string defn) ")\n"))))
   (current-global-map))
  (insert ")")
)
#+END_SRC

;;; ************************************************
;; Returns all base-keys in mousemodded unless they are listed in mousebase and all modified-keys unless they are listed in pkb-include-mouse-modifier
#+BEGIN_SRC emacs-lisp
(let (bases mods)
  (dolist (key mousemodded)
    (unless (memq (event-basic-type key) mousebase)
      (add-to-list 'bases (event-basic-type key) t))
    (dolist (mod (event-modifiers key))
      (unless (memq mod pkb-include-mouse-modifier)
	(add-to-list 'mods mod t))))
  (in-pr bases)
  (insert "\n")
  (in-pr mods)
)
(wheel-down wheel-up mouse-1 mouse-2 mouse-3 mouse-4)
(click drag down double triple)
#+END_SRC

;;;; ************************************************
;; Understand how keymaps work with char-ranges and Meta/ESC-map
#+BEGIN_SRC emacs-lisp

(lookup-key (current-global-map) [27])
(in-pr (symbol-function 'ESC-prefix))

(map-keymap 'print-keymap-func (lookup-key (current-local-map) (vector 27)))
#+END_SRC

;;;; ************************************************
;; Pare keymaps

;; returns a version of (accessible-keymaps KEYMAP) without pks listed in PKS-TO-IGNORE
#+BEGIN_SRC emacs-lisp

(defun pare-accessible-keymaps(keymap)
  (let ((pks-to-ignore '([]))
	(akmps (accessible-keymaps keymap)))
    (dolist (pref-w-keymap akmps)
      (when (member (car pref-w-keymap) pks-to-ignore)
	(setq akmps (delq pref-w-keymap akmps))))
    akmps)
)

(in-pr (pare-accessible-keymaps (current-global-map)))
#+END_SRC

;; returns a version of keymap without events in ignore-list
#+BEGIN_SRC emacs-lisp
(defun pare-keymap (keymap) 
  (let ((ignore-list '(menu-bar tool-bar))
	(kmcopy (copy-sequence keymap)))
    (map-keymap
     (lambda (event bind)
       (when (member event ignore-list)
	   ;; (and (consp key-w-binding)
	   ;;      (not (vectorp (car key-w-binding))))
	  (define-key kmcopy (vector event) nil)))
     kmcopy)
    kmcopy)
)
#+END_SRC

;;;; ************************************************
;; Test char-ranges and keymaps
#+BEGIN_SRC emacs-lisp

(setq tst (make-keymap))

(dolist (key
	  (let (veclst)
	    (dolist (elem (number-sequence #1=?\H-a (- #1# 20) -1))
	      (add-to-list 'veclst (vector elem) t))
	    veclst))
  (define-key tst key 'defn)
)

(dolist (key
	  (let (veclst)
	    (dolist (elem (number-sequence #1=70 (+ #1# 10)))
	      (add-to-list 'veclst (vector elem) t))
	    veclst))
  (define-key tst key 'defn)
)

(map-keymap 'print-keymap-func tst)
#+END_SRC

;;;; ************************************************
;; test pkb-accessible-keymaps
#+BEGIN_SRC emacs-lisp

(in-pr
 (pkb-accessible-keymaps
  '(keymap (?a keymap (?b . binding) (?c . binding2))
	   (?c keymap (?d . binding3) (?g keymap (?q . binding4)))
	   (?h keymap (?p . binding5) (?\C-w keymap (?a . binding5))))
  ))

(in-pr
 (pkb-accessible-keymaps 
  '(keymap (a keymap (aa . binding) (ab . binding2))
	   (b keymap (ba . binding3) (bb keymap (bba . binding4)))
	   (c keymap
	      (ca . binding5)
	      (cb keymap
		  (cba . binding5)
		  (cbb keymap (cbba . bind)))
	      (cc keymap
		  (cca . binding5)
		  (ccb keymap (ccba . bind)))))
  '([b] [c]) '([b bb] ([c cb]))
  ))

(in-pr
 (pkb-accessible-keymaps 
  (current-global-map)
  '([?\C-x])
  ))
#+END_SRC

;;;; ************************************************
;; test pkb-categorize-key-list
#+BEGIN_SRC emacs-lisp

(in-pr (pkb-categorize-key-list (pkb-list-keys (current-global-map))))

(let ((km (make-keymap)))
  (define-key km [?\M-\e] 'bind01)
  (define-key km [?a] 'bind02)
  (define-key km [?\C-a] 'bind03)
  (define-key km [?\C-q] 'bind04)
  (define-key km [?f] 'bind05)
  (define-key km [?g] 'bind06)
  (define-key km [?\M-7] 'bind07)
  (define-key km [?\M-9] 'bind08)
  (define-key km [(?1 . ?9)] 'bind09)
  (define-key km [?\[] 'bind10)
  (let* ((list-keys (pkb-list-keys km nil t))
	 (categorized-keys
	  (pkb-categorize-key-list list-keys 6 13 '(t t t))))
    (in-pr categorized-keys)
    ;; (in-pr-map 'map-char-table (nth 1 list-keys))
    )
)

(let ((km (make-keymap)))
  (define-key km [(?1 . ?9)] 'bind9)
  (let* ((list-keys (pkb-list-keys km nil t))
	 (categorized-keys
	  (pkb-categorize-key-list list-keys 0 13 '(t t t))))
    (in-pr categorized-keys)
    ;; (in-pr-map 'map-char-table (nth 1 list-keys))
    )
)

(let ((proc-list-keys
       (pkb-categorize-key-list (pkb-list-keys (current-global-map) nil t)
				7 13)))
  (in-pr proc-list-keys))
#+END_SRC

;;;; ************************************************
;; Generate lists for key-groups
#+BEGIN_SRC emacs-lisp

(key-description (vector (aref "abc" 0)))

(defun explode-string (stringi)
  "Return a list where each character of STRINGI is an element."
  (let (char-list char-list-lc)
    (dotimes (i (length stringi))
      (add-to-end-of-list char-list (key-description (vector (aref stringi i))) char-list-lc))
    char-list)
)

(in-pr (explode-string "`1234567890-+"))
(?` ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?0 ?- ?+)

(in-pr (explode-string "~!@#$%^&*()_+"))
(?~ ?! ?@ ?# ?$ ?% ?^ ?& ?* ?( ?) ?_ ?+)

(in-pr (explode-string "qwertyuiop[]\\{}|"))
(?q ?w ?e ?r ?t ?y ?u ?i ?o ?p ?[ ?] ?\\ ?{ ?} ?|)

(in-pr (explode-string "asdfghjkl;':\""))
(?a ?s ?d ?f ?g ?h ?j ?k ?l ?\; ?' ?: ?\")

(in-pr (explode-string "zxcvbnm,./<>?"))
(?z ?x ?c ?v ?b ?n ?m ?, ?. ?/ ?< ?> ??)
#+END_SRC

;;;; ************************************************
;; Experiment with map-char-table oddity
#+BEGIN_SRC emacs-lisp

(let ((ct (make-char-table 'keymap)) permev)
  (set-char-table-range ct '(1 . 2) 'binding)
  (map-char-table
   (lambda (event defn)
     (setq permev event)
     (insert (prin1-to-string permev)))
   ct)
  (insert (concat "\n" (prin1-to-string permev)))
  )
(1 . 2)
(3 . 4194303)
#+END_SRC

;;;; ************************************************
;; Test pkb-sort-pks-list
#+BEGIN_SRC emacs-lisp

(in-pr (pkb-sort-pks-list
 '(
   ([] simple bks-w-bindings1)
   ([?b] simple ( (?w . binding3) (?\M-t . binding4)))
   ([?u] compact bks-w-bindings2)
   ([?\C-b] simple ( (?a . binding) (?q . binding2) ))
   ([?\C-\M-r] simple ( (?w . binding3) (?\M-t . binding4)))
   ([?t] simple ( (?w . binding3) (?\M-t . binding4)))
  )
 nil
))

(in-pr (pkb-sort-pks-list
 '(
   ([] simple ( (?q . binding1) (?\C-t . binding2)))
   ([?b] simple ( (?w . binding3) (?\M-t . binding4)))
   ([?q] compact compactbind)
  )
 nil
))
#+END_SRC

;;;; ************************************************
;; Understanding printing
#+BEGIN_SRC emacs-lisp

(progn (print 'The\ cat\ in)
(print "the hat")
(print " came back"))

(in-pr (progn (prin1 'The\ cat\ in)
(prin1 "the hat")
(prin1 " came back")))

(progn
(princ 'The\ cat)
(princ " in the \"hat\""))

(print 'The\ cat\ in (current-buffer))

The\ cat\ in

(prin1 'The\ cat\ in (current-buffer))
The\ cat\ in
(princ 'The\ cat\ in (current-buffer))
The cat in
(print "the hat came back" (current-buffer))

"the hat came back"

(prin1 "the hat came back" (current-buffer))
"the hat came back"
(princ "the hat came back" (current-buffer))
the hat came back
(print " in the \"hat\"" (current-buffer))

" in the \"hat\""

(prin1 " in the \"hat\"" (current-buffer))
" in the \"hat\""
(princ " in the \"hat\"" (current-buffer))
 in the "hat"
end
#+END_SRC


;;;; ************************************************
;; Does deleting the current entry screw up dolist? (answer: no)
#+BEGIN_SRC emacs-lisp

(let ((lst (list 1 2 3 4 5)))
  (dolist (elt lst)
    (insert (concat (prin1-to-string elt) ": " (prin1-to-string lst) "\n"))
    (when (eq elt 2)
      (setq lst (delq 2 lst))
      (insert
       (concat "After del - " (prin1-to-string elt) ": " (prin1-to-string lst)
	       "\n")))
    )
)

1: (1 2 3 4 5)
2: (1 2 3 4 5)
After del - 2: (1 3 4 5)
3: (1 3 4 5)
4: (1 3 4 5)
5: (1 3 4 5)

(let ((lst (list 1 2 3 4 5)))
  (dolist (elt lst)
    (insert (concat (prin1-to-string elt) ": " (prin1-to-string lst) "\n"))
    (when (eq elt 2)
      (setq lst (delq 3 lst))
      (insert
       (concat "After del - " (prin1-to-string elt) ": " (prin1-to-string lst)
	       "\n")))
    )
)
1: (1 2 3 4 5)
2: (1 2 3 4 5)
After del - 2: (1 2 4 5)
4: (1 2 4 5)
5: (1 2 4 5)
#+END_SRC

;;;; ************************************************
;; Understanding link between escape and 27 = ?\C-\[
#+BEGIN_SRC emacs-lisp

(in-pr (key-description (vector (event-basic-type 27))))
"["

(in-pr (event-modifiers 27))
(control)

(in-pr (event-convert-list '(control 27)))
27

(in-pr (event-convert-list '(meta 27)))
134217755

(in-pr (key-description (vector (event-convert-list '(meta 27)))))
"M-ESC"

(in-pr (key-description (vector (event-convert-list '(alt 27)))))
"A-ESC"

(in-pr (key-description (vector (event-convert-list '(control ?\[)))))
"ESC"

(in-pr (key-description (vector (event-convert-list '(meta ?\[)))))
"M-["

(in-pr
 (key-description (vector (event-convert-list '(control meta ?\[)))))
"M-ESC"

(in-pr
 (key-description (vector (event-convert-list '(alt ?\[)))))
"A-["

(in-pr
 (key-description (vector (event-convert-list '(alt control ?\[)))))
"A-ESC"

(in-pr (lookup-key (current-global-map) [?\M-\e]))
(keymap (58 . eval-expression) (27 . keyboard-escape-quit))

(in-pr (key-description [58])) ":"

(describe-key [27 ?\H-\e]) (execute-kbd-macro [27 27 27])
(key-description [27 ?\H-\M-[]))

(in-pr (key-description (vector ?\C-\e)))
"C-ESC"

(in-pr (key-description (vector (event-basic-type ?\C-\e)))) "["
(in-pr (event-modifiers ?\C-\e)) (control)

(let ((km (make-keymap)))
  (define-key km [?\C-\e] 'bind)
  (in-pr km)
)
(keymap #^[nil nil keymap nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] (67108891 . bind))

(let ((km (make-keymap)))
  (define-key km [?\e] 'bind)
  (in-pr km)
)

(in-pr ?\M-\e)		134217755
(in-pr ?\C-\M-\[)	134217755
(describe-key [?\C-\e])

(describe-key [?\C-h ?k])
(describe-key [C-escape])
(in-pr (read-key-sequence "Sequence:")) [C-escape]
(in-pr (read-key-sequence "Sequence:")) "q"
(in-pr (read-key-sequence-vector "Sequence:")) [27 113]
(in-pr (read-key-sequence-vector "Sequence:")) [C-escape]
(in-pr (read-event)) escape
(in-pr (read-event)) C-escape
(in-pr (read-event)) M-escape
(in-pr (read-event)) 
(in-pr meta-prefix-char) 27
(in-pr (read-key)) 27
(in-pr (read-key)) C-escape
(in-pr (lookup-key (current-global-map) [C-escape])) electric-buffer-list
#+END_SRC

;;;; ************************************************
;; Key translation
#+BEGIN_SRC emacs-lisp

(in-pr keyboard-translate-table) nil

(in-pr extra-keyboard-modifiers) 0

(in-pr input-decode-map)
(keymap (27 keymap (C-backspace) (C-delete)) (C-M-backspace) (C-M-delete) (M-backspace) (M-delete))

(in-pr local-function-key-map)
(keymap (C-tab . [134217737]) (8388721 . [134217737]) (s-tab . [134217737]) (backspace . [127]) (kp-delete . [4]) (delete . [4]) keymap (S-iso-lefttab . [backtab]) (iso-lefttab . [backtab]) (M-escape . [134217755]) (M-return . [134217741]) (M-clear . [134217740]) (M-linefeed . [134217738]) (M-tab . [134217737]) (M-delete . [134217855]) (M-backspace . [134217855]) keymap (escape . [27]) (return . [13]) (clear . [12]) (linefeed . [10]) (tab . [9]) (kp-equal . [61]) (kp-divide . [47]) (kp-decimal . [46]) (kp-subtract . [45]) (kp-separator . [44]) (kp-add . [43]) (kp-multiply . [42]) (kp-enter . [13]) (kp-tab . [9]) (kp-space . [32]) (kp-9 . [57]) (kp-8 . [56]) (kp-7 . [55]) (kp-6 . [54]) (kp-5 . [53]) (kp-4 . [52]) (kp-3 . [51]) (kp-2 . [50]) (kp-1 . [49]) (kp-0 . [48]) (24 keymap (64 keymap (99 . event-apply-control-modifier) (83 . event-apply-shift-modifier) (97 . event-apply-alt-modifier) (109 . event-apply-meta-modifier) (115 . event-apply-super-modifier) (104 . event-apply-hyper-modifier))) (0 . [67108896]) (C-S-kp-9 . [C-S-prior]) (C-S-kp-8 . [C-S-up]) (C-S-kp-7 . [C-S-home]) (C-S-kp-6 . [C-S-right]) (C-S-kp-4 . [C-S-left]) (C-S-kp-3 . [C-S-next]) (C-S-kp-2 . [C-S-down]) (C-S-kp-1 . [C-S-end]) (C-S-kp-prior . [C-S-prior]) (C-S-kp-up . [C-S-up]) (C-S-kp-home . [C-S-home]) (C-S-kp-right . [C-S-right]) (C-S-kp-left . [C-S-left]) (C-S-kp-next . [C-S-next]) (C-S-kp-down . [C-S-down]) (C-S-kp-end . [C-S-end]) (S-kp-prior . [S-prior]) (S-kp-up . [S-up]) (S-kp-home . [S-home]) (S-kp-right . [S-right]) (S-kp-left . [S-left]) (S-kp-next . [S-next]) (S-kp-down . [S-down]) (S-kp-end . [S-end]) (kp-delete . [127]) (delete . [127]) (backspace . [127]) (kp-insert . [insert]) (kp-begin . [begin]) (kp-end . [end]) (M-kp-next . [M-next]) (kp-next . [next]) (kp-prior . [prior]) (kp-down . [down]) (kp-right . [right]) (kp-up . [up]) (kp-left . [left]) (kp-home . [home]))

(in-pr function-key-map)
(keymap (escape . [27]) (return . [13]) (clear . [12]) (linefeed . [10]) (tab . [9]) (kp-equal . [61]) (kp-divide . [47]) (kp-decimal . [46]) (kp-subtract . [45]) (kp-separator . [44]) (kp-add . [43]) (kp-multiply . [42]) (kp-enter . [13]) (kp-tab . [9]) (kp-space . [32]) (kp-9 . [57]) (kp-8 . [56]) (kp-7 . [55]) (kp-6 . [54]) (kp-5 . [53]) (kp-4 . [52]) (kp-3 . [51]) (kp-2 . [50]) (kp-1 . [49]) (kp-0 . [48]) (24 keymap (64 keymap (99 . event-apply-control-modifier) (83 . event-apply-shift-modifier) (97 . event-apply-alt-modifier) (109 . event-apply-meta-modifier) (115 . event-apply-super-modifier) (104 . event-apply-hyper-modifier))) (0 . [67108896]) (C-S-kp-9 . [C-S-prior]) (C-S-kp-8 . [C-S-up]) (C-S-kp-7 . [C-S-home]) (C-S-kp-6 . [C-S-right]) (C-S-kp-4 . [C-S-left]) (C-S-kp-3 . [C-S-next]) (C-S-kp-2 . [C-S-down]) (C-S-kp-1 . [C-S-end]) (C-S-kp-prior . [C-S-prior]) (C-S-kp-up . [C-S-up]) (C-S-kp-home . [C-S-home]) (C-S-kp-right . [C-S-right]) (C-S-kp-left . [C-S-left]) (C-S-kp-next . [C-S-next]) (C-S-kp-down . [C-S-down]) (C-S-kp-end . [C-S-end]) (S-kp-prior . [S-prior]) (S-kp-up . [S-up]) (S-kp-home . [S-home]) (S-kp-right . [S-right]) (S-kp-left . [S-left]) (S-kp-next . [S-next]) (S-kp-down . [S-down]) (S-kp-end . [S-end]) (kp-delete . [127]) (delete . [127]) (backspace . [127]) (kp-insert . [insert]) (kp-begin . [begin]) (kp-end . [end]) (M-kp-next . [M-next]) (kp-next . [next]) (kp-prior . [prior]) (kp-down . [down]) (kp-right . [right]) (kp-up . [up]) (kp-left . [left]) (kp-home . [home]))

(in-pr key-translation-map)
(keymap (24 keymap (56 . iso-transl-ctl-x-8-map)))
#+END_SRC

;;;; ************************************************
;; Understanding how emacs parses basic-types
#+BEGIN_SRC emacs-lisp

'escape
(lookup-key (current-global-map) [escape])
(fset 'abc
   [prior])
(execute-kbd-macro [escape escape escape])
(event-modifiers 'C-escape)
(event-basic-type 'C-escape)

(event-modifiers 'C-M-escape)
(event-basic-type 'C-M-escape)

(defun db-event-basic-type (event)
  "Return the basic type of the given event (all modifiers removed).
The value is a printing character (not upper case) or a symbol.
EVENT may be an event or an event type.  If EVENT is a symbol
that has never been used in an event that has been read as input
in the current Emacs session, then this function may return nil."
  (if (consp event)
      (setq event (car event)))
  (if (symbolp event)
      (car (get event 'event-symbol-elements))
    (let* (base uncontrolled)
      (setq base (logand event (1- ?\A-\^@)))
      (setq uncontrolled (if (< base 32) (logior base 64) base))
      ;; There are some numbers that are invalid characters and
      ;; cause `downcase' to get an error.
      (condition-case ()
	  (downcase uncontrolled)
	(error uncontrolled)))))
#+END_SRC

;;;; ************************************************
;; Test PKB-SPLIT-FULL-TO-GROUPS
#+BEGIN_SRC emacs-lisp

(setq key-groups 
 '( ( ("full")
      (?` ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?0 ?- ?=)
      (?~ ?! ?@ ?# ?$ ?% ?^ ?& ?* ?( ?) ?_ ?+)
      (?q ?w ?e ?r ?t ?y ?u ?i ?o ?p ?[ ?] ?\\ ?{ ?} ?|)
      (?a ?s ?d ?f ?g ?h ?j ?k ?l ?\; ?' ?: ?\")
      (?z ?x ?c ?v ?b ?n ?m ?, ?. ?/ ?< ?> ??))
    ( ("LHS of notebook")
      (insert home prior next end))
  )
)

(let* ((list-keys (pkb-list-keys (current-global-map) nil t))
       (categorized-keys
	(pkb-categorize-key-list list-keys 6 13 t))
       (split-for-full
	(pkb-split-full-to-groups (cdr categorized-keys) key-groups))
       )
  (in-pr split-for-full)
  ;; (in-pr-map 'map-char-table (nth 1 list-keys))
  )
#+END_SRC

;;;; ************************************************
;; Understand string-match
#+BEGIN_SRC emacs-lisp

(progn
  (let ((str "I go to the hi,p town"))
    (string-match "hi\\(.\\)p" str)
    ;; (match-string 0 str)
    (replace-match "go\\1to" nil nil str)
  )
)
forward-next
(progn
  (let ((str "f3"))
    (if (string-match     "\\(\\W\\|^\\)f\\([0-9].*\\)$" str)
    ;; (match-string 0 str)
	(replace-match
	  "\\1F\\2" nil nil str)
      "no match")
  )
)


(progn
  (let ((str "I go to the hi,p town"))
    (string-match "hi\\(.\\)p" str)
    ;; (match-string 0 str)
    (match-substitute-replacement "go\\1to" nil nil str)
  )
)

(progn
  (let ((str "I go to the hi,p town"))
    (string-match "hi.p" str)
    ;; (match-string 0 str)
  )
)

(defun test-fcn (fcn)
  (funcall fcn "abc")
)

(test-fcn (lambda (inp) (insert inp)))
#+END_SRC

;;;; ************************************************
;; making dolist-cons
#+BEGIN_SRC emacs-lisp

(defmacro dolist-cons (spec &rest body)
  "Loop over a list.
Evaluate BODY with VAR bound to each cons from LIST, in turn.
Then evaluate RESULT to get return value, default nil.

\(fn (VAR LIST [RESULT]) BODY...)"
  (declare (indent 1) (debug ((symbolp form &optional form) body)))
  ;; It would be cleaner to create an uninterned symbol,
  ;; but that uses a lot more space when many functions in many files
  ;; use dolist.
  `(let ((,(car spec) ,(nth 1 spec)))
    (while ,(car spec)
      ,@body
      (setq ,(car spec) (cdr ,(car spec))))
    ,@(if (cdr (cdr spec))
	  `((setq ,(car spec) nil) ,@(cdr (cdr spec))))
    )
)

(in-pr (macroexpand '(dolist (var list result) body)))
(let ((--dolist-tail-- list) var)
  (while --dolist-tail--
    (setq var (car --dolist-tail--))
    body
    (setq --dolist-tail-- (cdr --dolist-tail--)))
  (setq var nil) result
)

(in-pr (macroexpand '(dolist-cons (var list result) body)))
(let ((var list))
  (while var
    body
    (setq var (cdr var)))
  (setq var nil)
  result
)

(in-pr (macroexpand '(dolist-cons (var list) body)))
(let ((var list))
  (while var
    body
    (setq var (cdr var))))
#+END_SRC

;; ************************************************
;; Diagnose issue with SPC and DEL
#+BEGIN_SRC emacs-lisp

(in-pr (key-description (kbd "M-SPC")))
"M-SPC"

(in-pr (event-basic-type (aref (kbd "M-SPC")0 )))
32

(in-pr (event-description (event-basic-type (aref (kbd "M-SPC")0 ))))
"SPC"

(in-pr (key-description (kbd "SPC")))
"SPC"

(in-pr (event-basic-type (aref (kbd "SPC")0 )))
32

(in-pr (pkb-list-keys (lookup-key (current-global-map) [f1])))

(in-pr-map 'map-char-table (nth 1 (pkb-list-keys (lookup-key (current-global-map) [f1]))))

(in-pr (pkb-categorize-key-list (pkb-list-keys (lookup-key (current-global-map) [f1])) 4 12))

(in-pr (pkb-split-full-to-groups (cdr (pkb-categorize-key-list (pkb-list-keys (lookup-key (current-global-map) [f1])) 4 12)) pkb-key-groups))
#+END_SRC

;; ************************************************
;; understanding event-modifiers and integer events < 127
#+BEGIN_SRC emacs-lisp

(progn
  (insert "( ")
  (dotimes (i 128)
    (insert (if (= (mod i 6) 0) "\n " "")
	    "(" (number-to-string i) ": "
	    (prin1-to-string (event-description i)) ") "))
  (insert ") ")
)
( 
 (0: "C-@") (1: "C-a") (2: "C-b") (3: "C-c") (4: "C-d") (5: "C-e") 
 (6: "C-f") (7: "C-g") (8: "C-h") (9: "TAB") (10: "C-j") (11: "C-k") 
 (12: "C-l") (13: "RET") (14: "C-n") (15: "C-o") (16: "C-p") (17: "C-q") 
 (18: "C-r") (19: "C-s") (20: "C-t") (21: "C-u") (22: "C-v") (23: "C-w") 
 (24: "C-x") (25: "C-y") (26: "C-z") (27: "ESC") (28: "C-\\") (29: "C-]") 
 (30: "C-^") (31: "C-_") (32: "SPC") (33: "!") (34: "\"") (35: "#") 
 (36: "$") (37: "%") (38: "&") (39: "'") (40: "(") (41: ")") 
 (42: "*") (43: "+") (44: ",") (45: "-") (46: ".") (47: "/") 
 (48: "0") (49: "1") (50: "2") (51: "3") (52: "4") (53: "5") 
 (54: "6") (55: "7") (56: "8") (57: "9") (58: ":") (59: ";") 
 (60: "<") (61: "=") (62: ">") (63: "?") (64: "@") (65: "A") 
 (66: "B") (67: "C") (68: "D") (69: "E") (70: "F") (71: "G") 
 (72: "H") (73: "I") (74: "J") (75: "K") (76: "L") (77: "M") 
 (78: "N") (79: "O") (80: "P") (81: "Q") (82: "R") (83: "S") 
 (84: "T") (85: "U") (86: "V") (87: "W") (88: "X") (89: "Y") 
 (90: "Z") (91: "[") (92: "\\") (93: "]") (94: "^") (95: "_") 
 (96: "`") (97: "a") (98: "b") (99: "c") (100: "d") (101: "e") 
 (102: "f") (103: "g") (104: "h") (105: "i") (106: "j") (107: "k") 
 (108: "l") (109: "m") (110: "n") (111: "o") (112: "p") (113: "q") 
 (114: "r") (115: "s") (116: "t") (117: "u") (118: "v") (119: "w") 
 (120: "x") (121: "y") (122: "z") (123: "{") (124: "|") (125: "}") 
 (126: "~") (127: "DEL") )  

(progn
  (insert "( ")
  (dotimes (i 128)
    (insert "(" (number-to-string i) ": "
	    (number-to-string (event-basic-type i)) ")\n"))
  (insert ") ")
)
( (0: 64)
(1: 97)
(2: 98)
(3: 99)
(4: 100)
(5: 101)
(6: 102)
(7: 103)
(8: 104)
(9: 105)
(10: 106)
(11: 107)
(12: 108)
(13: 109)
(14: 110)
(15: 111)
(16: 112)
(17: 113)
(18: 114)
(19: 115)
(20: 116)
(21: 117)
(22: 118)
(23: 119)
(24: 120)
(25: 121)
(26: 122)
(27: 91)
(28: 92)
(29: 93)
(30: 94)
(31: 95)
(32: 32)
(33: 33)
(34: 34)
(35: 35)
(36: 36)
(37: 37)
(38: 38)
(39: 39)
(40: 40)
(41: 41)
(42: 42)
(43: 43)
(44: 44)
(45: 45)
(46: 46)
(47: 47)
(48: 48)
(49: 49)
(50: 50)
(51: 51)
(52: 52)
(53: 53)
(54: 54)
(55: 55)
(56: 56)
(57: 57)
(58: 58)
(59: 59)
(60: 60)
(61: 61)
(62: 62)
(63: 63)
(64: 64)
(65: 97)
(66: 98)
(67: 99)
(68: 100)
(69: 101)
(70: 102)
(71: 103)
(72: 104)
(73: 105)
(74: 106)
(75: 107)
(76: 108)
(77: 109)
(78: 110)
(79: 111)
(80: 112)
(81: 113)
(82: 114)
(83: 115)
(84: 116)
(85: 117)
(86: 118)
(87: 119)
(88: 120)
(89: 121)
(90: 122)
(91: 91)
(92: 92)
(93: 93)
(94: 94)
(95: 95)
(96: 96)
(97: 97)
(98: 98)
(99: 99)
(100: 100)
(101: 101)
(102: 102)
(103: 103)
(104: 104)
(105: 105)
(106: 106)
(107: 107)
(108: 108)
(109: 109)
(110: 110)
(111: 111)
(112: 112)
(113: 113)
(114: 114)
(115: 115)
(116: 116)
(117: 117)
(118: 118)
(119: 119)
(120: 120)
(121: 121)
(122: 122)
(123: 123)
(124: 124)
(125: 125)
(126: 126)
(127: 127)
)  

(progn
  (insert "( ")
  (dotimes (i 128)
    (let (match)
      (setq match
	    (catch 'result
	      (dotimes (j i)
		(when (and (equal (event-basic-type i) (event-basic-type j))
			   (< j i))
		  (throw 'result j)))
	      nil))
      (when match
	(insert "  (" (number-to-string i) ": " (number-to-string match)
		")\n"))))
  (insert ") ")
)
(   (64: 0)
  (65: 1)
  (66: 2)
  (67: 3)
  (68: 4)
  (69: 5)
  (70: 6)
  (71: 7)
  (72: 8)
  (73: 9)
  (74: 10)
  (75: 11)
  (76: 12)
  (77: 13)
  (78: 14)
  (79: 15)
  (80: 16)
  (81: 17)
  (82: 18)
  (83: 19)
  (84: 20)
  (85: 21)
  (86: 22)
  (87: 23)
  (88: 24)
  (89: 25)
  (90: 26)
  (91: 27)
  (92: 28)
  (93: 29)
  (94: 30)
  (95: 31)
  (97: 1)
  (98: 2)
  (99: 3)
  (100: 4)
  (101: 5)
  (102: 6)
  (103: 7)
  (104: 8)
  (105: 9)
  (106: 10)
  (107: 11)
  (108: 12)
  (109: 13)
  (110: 14)
  (111: 15)
  (112: 16)
  (113: 17)
  (114: 18)
  (115: 19)
  (116: 20)
  (117: 21)
  (118: 22)
  (119: 23)
  (120: 24)
  (121: 25)
  (122: 26)
) 

(progn
  (insert "( ")
  (dotimes (i 128)
    (let (match-list)
    (dotimes (j 128)
      (when (equal i (event-basic-type j))
	(add-to-list 'match-list j t)))
    (when match-list
      (insert "  (" (number-to-string i) ": ")
      (dolist (match match-list)
	(insert (number-to-string match) " "))
      (insert ")\n"))))
  (insert ") ")
)
#+END_SRC
;; C-bk, S-bk is an integer if 97-122
;; C-bk is an integer if 64, 91-95, 97-122
#+BEGIN_SRC emacs-lisp
(   (32: 32 )
    (33: 33 )
    (34: 34 )
    (35: 35 )
    (36: 36 )
    (37: 37 )
    (38: 38 )
    (39: 39 )
    (40: 40 )
    (41: 41 )
    (42: 42 )
    (43: 43 )
    (44: 44 )
    (45: 45 )
    (46: 46 )
    (47: 47 )
    (48: 48 )
    (49: 49 )
    (50: 50 )
    (51: 51 )
    (52: 52 )
    (53: 53 )
    (54: 54 )
    (55: 55 )
    (56: 56 )
    (57: 57 )
    (58: 58 )
    (59: 59 )
    (60: 60 )
    (61: 61 )
    (62: 62 )
    (63: 63 )
    (64: 0 64 )
    (91: 27 91 )
    (92: 28 92 )
    (93: 29 93 )
    (94: 30 94 )
    (95: 31 95 )
    (96: 96 )
    (97: 1 65 97 )
    (98: 2 66 98 )
    (99: 3 67 99 )
    (100: 4 68 100 )
    (101: 5 69 101 )
    (102: 6 70 102 )
    (103: 7 71 103 )
    (104: 8 72 104 )
    (105: 9 73 105 )
    (106: 10 74 106 )
    (107: 11 75 107 )
    (108: 12 76 108 )
    (109: 13 77 109 )
    (110: 14 78 110 )
    (111: 15 79 111 )
    (112: 16 80 112 )
    (113: 17 81 113 )
    (114: 18 82 114 )
    (115: 19 83 115 )
    (116: 20 84 116 )
    (117: 21 85 117 )
    (118: 22 86 118 )
    (119: 23 87 119 )
    (120: 24 88 120 )
    (121: 25 89 121 )
    (122: 26 90 122 )
    (123: 123 )
    (124: 124 )
    (125: 125 )
    (126: 126 )
    (127: 127 )
    )
#+END_SRC

;; ************************************************
;; what does accessible-keymaps do if there are two ways to reach keymap
#+BEGIN_SRC emacs-lisp

(let ((km1 (make-sparse-keymap))
      (km2 (make-sparse-keymap)))
  (define-key km1 [?a] km2)
  (define-key km1 [?b] km2)
  (define-key km1 [?c] 'a)
  (in-pr (accessible-keymaps km1))
)

(([] keymap (99 . a) (98 . #1=(keymap)) (97 . #1#))
 ([98] . #1#)
 ([97] . #1#))
#+END_SRC

;; ************************************************
#+BEGIN_SRC emacs-lisp

(let ((item ?\C-\M-k))
  (substring (prin1-to-string (event-convert-list
			       (append (event-modifiers item) '(abc)))) 0 -3)
)

(let ((test-km (make-keymap)))
  (define-key test-km [?\M-\C-5] 'abc)
  (define-key test-km [?\M-\C-5] 'cde)
  (in-pr test-km))
(mapconcat 'identity '("hi" "bye") " ")

(mapconcat 'identity nil " ")

(setq str "ght")
(string-match "abc" 

(pkb-html-save-keymap (current-global-map) "~/test.html")
#+END_SRC

