* investigate how keys are resolved

** split event into "basic type", "modifiers"
(let ((formatting "| %20s | %20s | %20s |\n"))
  (insert "(\n")
  (insert (format formatting "event [raw] " "basic type [raw] " "modifiers "))
  (insert
   (let ((tsfm-formatting (format formatting "-" "-" "-")))
     (setf tsfm-formatting (replace-regexp-in-string " " "-" tsfm-formatting))
     (setf tsfm-formatting (replace-regexp-in-string "|" "+" tsfm-formatting))
     (setf (elt tsfm-formatting 0) ?|)
     (setf (elt tsfm-formatting (- (length tsfm-formatting) 2)) ?|)
     tsfm-formatting))
  (unwind-protect
    (while t (let ((event (read-event "Generate event:")))
	       (insert
		(format formatting
			;; event
			(concat (key-description (vector event)) " ["
				(prin1-to-string event) "]")
			;; basic type
			(let ((basic-type (event-basic-type event)))
			  (concat
			   (key-description (vector basic-type)) " ["
			   (prin1-to-string basic-type) "]"))
			;; event-modifiers
			(event-modifiers event)
			))))
    (insert ")\n")))
(
| event [raw]                     | basic type [raw]        | modifiers      |
|---------------------------------+-------------------------+----------------|
| f [102]                         | f [102]                 | nil            |
| j [106]                         | j [106]                 | nil            |
| D [68]                          | d [100]                 | (shift)        |
| <return> [return]               | <return> [return]       | nil            |
| <M-S-f4> [M-S-f4]               | <f4> [f4]               | (meta shift)   |
| C-l [12]                        | l [108]                 | (control)      |
| <C-M-backspace> [C-M-backspace] | <backspace> [backspace] | (meta control) |
)

** Print a key-sequence including the prefix arguments via this-command-keys/this-command-keys-vector

;;  To print a key-sequence including prefix arguments, we need to use this-command-keys/this-command-keys-vector but not using 'read-key-sequence'. Thus, we need to define a key-sequence that runs this-command-keys-....

(local-set-key [?q] (lambda () (interactive) (in-pr (this-command-keys-vector))))
[21 113]
[67108909 67108921 49 49 50 113]
(local-unset-key [?q])

** Print event, before/post translation

(let* (begin-mark end-mark (formatting "| %12s | %12s |\n")
		  row-group-divider)
  ;; make ROW-GROUP-DIVIDER
  (setf row-group-divider (format formatting "-" "-"))
  (setf row-group-divider (replace-regexp-in-string " " "-" row-group-divider))
  (setf row-group-divider (replace-regexp-in-string "|" "+" row-group-divider))
  (setf (elt row-group-divider 0) ?|)
  (setf (elt row-group-divider (- (length row-group-divider) 2)) ?|)

  (insert "(\n")
  (setq begin-mark (point-marker))
  (insert (format formatting "before" "after"))
  (insert (format formatting "tsltn" "tsln"))
  (insert row-group-divider)
  (unwind-protect
      (let (key-read raw-key)
	(while (and (not (equal key-read ?q)))
	(setq key-read (read-key "Generate event (quit with \"q\"):"))
	(setq raw-key (this-single-command-raw-keys))
	(insert
	 (format formatting
		 (concat (key-description raw-key) " "(prin1-to-string raw-key))
		 (concat (key-description (vector key-read)) " (" (prin1-to-string key-read)  ")"))))
	(setq end-mark (point-marker))
	(org-table-align)
	(goto-char (marker-position end-mark)))
    (insert ")\n")))

(
| before                  | after           |
| tsltn                   | tsln            |
|-------------------------+-----------------|
| SPC [32]                | SPC (32)        |
| <backspace> [backspace] | DEL (127)       |
| <escape> [escape]       | ESC (27)        |
| M-w [134217847]         | M-w (134217847) |
| q [113]                 | q (113)         |
)

** Print key-sequence, before/post translation

(let* (begin-mark end-mark (formatting "| %15s | %15s |\n")
		  row-group-divider)
  ;; make ROW-GROUP-DIVIDER
  (setf row-group-divider (format formatting "-" "-"))
  (setf row-group-divider (replace-regexp-in-string " " "-" row-group-divider))
  (setf row-group-divider (replace-regexp-in-string "|" "+" row-group-divider))
  (setf (elt row-group-divider 0) ?|)
  (setf (elt row-group-divider (- (length row-group-divider) 2)) ?|)

  (insert "(\n")
  (setq begin-mark (point-marker))
  (insert (format formatting "before" "after"))
  (insert (format formatting "tsltn" "tsln"))
  (insert row-group-divider)
  (unwind-protect
      (let (seq-read raw-seq)
	(while (not (equal seq-read [?q]))
	(setq seq-read (read-key-sequence-vector "Generate key-sequence (quit with \"q\"):" nil t))
	(setq raw-seq (this-single-command-raw-keys))
	(insert
	 (format formatting
		 (concat (key-description raw-seq) " " (prin1-to-string raw-seq))
		 (concat (key-description seq-read) " " (prin1-to-string seq-read)))))
	(setq end-mark (point-marker))
	(org-table-align)
	(goto-char (marker-position end-mark)))
    (insert ")\n")))
(
| before                        | after           |
| tsltn                         | tsln            |
|-------------------------------+-----------------|
| <backspace> [backspace]       | DEL [127]       |
| C-c <backspace> [3 backspace] | C-c DEL [3 127] |
| <escape> w [escape 119]       | M-w [27 119]    |
| M-w [134217847]               | M-w [134217847] |
| C-j [10]                      | C-j [10]        |
| q [113]                       | q [113]         |
)


** note that a keymap entry (?\M-e . defn), where e is some character and defn some definition, is never looked at in key lookup. However, it is found by `map-keymap'. The entries in ESC are both looked-up and found.

To see, this, try the following, and note that only defn1, defined in the ESC prefix, is accessed.

(let ((km (make-keymap)))
  (define-key km [?\M-a] `defn1)
  (setf km (list 'keymap '(?\M-a . defn2) '(?\M-b . defn3) (nth 1 km)))
  (use-local-map km)
  (pptcb km)
  (insert "\n")
  (ptcb-map 'map-keymap km)
  )
(keymap
 (134217825 . defn2)
 (134217826 . defn3)
 #^[nil nil keymap #1=
	#^^[3 0 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil
	      (keymap
	       (97 . defn1))
	      nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil]
	#^^[1 0
	      #^^[2 0 #1# nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil]
	      nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil]
	nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil])

((134217825 . defn2)
 (134217826 . defn3)
 (27 keymap
     (97 . defn1)))


* test my functions

** results of pkb-include-mk-p, pkb-include-base-key-list for a given key

(let ((formatting "| %20s | %20s | %20s |\n"))
  (insert "(\n")
  (insert (format formatting "event " " include base key? " " include event?"))
  (insert
   (let ((tsfm-formatting (format formatting "-" "-" "-")))
     (setf tsfm-formatting (replace-regexp-in-string " " "-" tsfm-formatting))
     (setf tsfm-formatting (replace-regexp-in-string "|" "+" tsfm-formatting))
     (setf (elt tsfm-formatting 0) ?|)
     (setf (elt tsfm-formatting (- (length tsfm-formatting) 2)) ?|)
     tsfm-formatting))
  (unwind-protect
      (while t (let ((event (read-event "Press key:")))
		 (insert
		  (format formatting
			  ;; event
			  (key-description (vector event))
			  ;; basic type
			  (not (null (or
				      (and (integerp event) (>= event 0) (< event 128))
				      (member (event-basic-type event)
				              pkb-include-base-key-list))))
			  (pkb-include-mk-p event)))))
    (insert ")\n")))

(
| event         | include base key? | include event? |
|---------------+-------------------+----------------|
| s             | t                 | t              |
| d             | t                 | t              |
| <C-backspace> | nil               | t              |
| <backspace>   | t                 | t              |
| <escape>      | t                 | t              |
| <M-f1>        | nil               | t              |
| <M-S-f5>      | nil               | t              |
| <prior>       | t                 | t              |
| <next>        | t                 | t              |
)

** Print members of `current-global-map' for which `pkb-include-mk-p' returns nil

Print members of `current-global-map' for which `pkb-include-mk-p' returns nil (and which aren't members of IGNORE-EVENT or undefined)

#+BEGIN_SRC emacs-lisp
(let ((ignore-event '(menu-bar tool-bar)))
  (insert "(")
  (map-keymap 
   (lambda (event defn)
     (unless (or (null defn)
		 (memq event ignore-event)
		 (pkb-include-mk-p event))
       (insert (concat "(" (prin1-to-string event) ": "
		       (prin1-to-string defn) ")\n"))))
   (current-global-map))
  (insert ")")
)

#+END_SRC


* investigate keymaps

** print a keymap's bindings

1 way:
  (in-pr-map 'map-keymap keymap)

e.g.
  (in-pr-map 'map-keymap (lookup-key (current-global-map) [f5]))

*** print a keymap's bindings, writing the bindings as keys

(cl-defun in-pr-keymap (keymap &optional (events-as-escape-sequences-flag t))
  "Print key bindings of KEYMAP. 
If EVENTS-AS-ESCAPE-SEQUENCES-FLAG (true, by default), print the events in
  KEYMAP using `character-code-to-escape-syntax'. "
  (in-pr-map
   (if keys-as-desc-fl
       (lambda (fcn km)
	 (map-keymap
	  (lambda (key defn)
	  
	    (funcall fcn (character-code-to-escape-syntax key) defn)) km))
     'map-keymap)
   keymap))

(cl-defun in-pr-keymap (keymap &optional (keys-as-desc-fl t))
  "Print key bindings of KEYMAP. 
If KEYS-AS-DESC-FL (true, by default), convert the events in KEYMAP using
`key-description' before printing. "
  (in-pr-map
   (if keys-as-desc-fl
       (lambda (fcn km)
	 (map-keymap
	  (lambda (key defn)
	    (funcall fcn (key-description (vector key)) defn)) km))
     'map-keymap)
   keymap))

(in-pr-keymap facemenu-keymap)
(("d": ("default" . facemenu-set-default))
 ("b": ("bold" . facemenu-set-bold))
 ("i": ("italic" . facemenu-set-italic))
 ("l": ("bold-italic" . facemenu-set-bold-italic))
 ("u": ("underline" . facemenu-set-underline))
 ("ESC": (keymap (115 . center-line) (83 . center-paragraph) (111 . font-lock-fontify-block)))
 ("o": ("Other..." . facemenu-set-face)))

** `pare-accessible-keymaps': same as `accessible-keymaps' but with the option to ignore selected prefix keys

#+BEGIN_SRC emacs-lisp
  (cl-defun pare-accessible-keymaps
      (keymap &optional (pks-to-ignore '([])))
    "Returns a version of (accessible-keymaps KEYMAP) without prefix keys listed in PKS-TO-IGNORE."
    (let ((akmps (accessible-keymaps keymap)))
      (dolist (pref-w-keymap akmps)
        (when (member (car pref-w-keymap) pks-to-ignore)
          (setq akmps (delq pref-w-keymap akmps))))
      akmps))

  (in-pr (pare-accessible-keymaps (current-local-map) '([] [3])))

#+END_SRC

** `pare-keymap': returns a copy of keymap without events in ignore-list

#+BEGIN_SRC emacs-lisp
  (cl-defun pare-keymap (keymap &optional (ignore-list '(menu-bar tool-bar)))
    "Returns a copy of KEYMAP without events in IGNORE-LIST"
    (let ((kmcopy (copy-keymap keymap)))
      (map-keymap
       (lambda (event bind)
         (when (member event ignore-list)
           ;; this operation is necessary for char-tables.
           (define-key kmcopy (vector event) nil)
           ;; I believe the following is OK to do.
           (setq kmcopy (assq-delete-all event kmcopy))))
       keymap)
      kmcopy))

  (in-pr (pare-keymap (current-local-map) '(menu-bar 27 3)))
#+END_SRC

** understanding `map-keymap' and char-tables

- Keymaps store definitions for character codes between 0 and ~(max-char)~ in
  char-tables.
- If consecutive keys in a char-table have the same definition, `map-keymap' lists
  those keys together in a range (START . END). To see this:

#+BEGIN_SRC emacs-lisp
    (let ((km (make-keymap)))
      (define-key km [1] 'defn1)
      (define-key km [2] 'defn1)
      (define-key km [3] 'defn2)
      (define-key km [4] 'defn1)
      (define-key km (vector (- (max-char) 1)) 'defn3)
      (define-key km (vector (max-char)) 'defn3)
      (define-key km (vector (+ (max-char) 1)) 'defn3)
      (define-key km (vector (+ (max-char) 2)) 'defn3)
      (in-pr km)
      (insert "\n")
      (in-pr-map 'map-keymap km))
  (keymap #^[nil nil keymap #1=
  #^^[3 0 nil defn1 defn1 defn2 defn1 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] #^^[1 0 #^^[2 0 #1# nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil] nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #^^[1 4128768 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #^^[2 4190208 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 
  #^^[3 4194176 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil defn3 defn3]]]] (4194305 . defn3) (4194304 . defn3))
  (((1 . 2): defn1)
   (3: defn2)
   (4: defn1)
   ((4194302 . 4194303): defn3)
   (4194305: defn3)
   (4194304: defn3))
#+END_SRC


** keys linked to particular modified keys, i.e. TAB = C-i, RET = C-m, ESC = C-[
*** note that this translation occurs early

Note that such translations happen very early, even before `input-decode-map', `local-function-key-map', and `key-translation-map'. The link seems to be quite fundamental. 

For example, `meta-prefix-char' doesn't appear to do anything when used on a terminal session because, in fact, the terminal automatically remaps meta keys to ESC. In fact, if I look at the buffer area when using describe-key ("C-h k") and entering a meta key command, I see ESC x (where x is some command) entered.

*** verifying that TAB = C-i, RET = C-m, ESC = C-[ are the unique in being mapped directly from modified keys

;; this assumes that the `key-description' command is in compliance with how
emacs internally deals events, but I think this is a safe assumption

(in-pr
 (cl-loop
  for code from 0 to 31
  for desc-basic-type = (key-description (vector (event-basic-type code)))
  for desc = (key-description (vector code))
  unless (equal desc (concat "C-" desc-basic-type))
  collect (list code desc desc-basic-type))
 )
((9 "TAB" "i") (13 "RET" "m") (27 "ESC" "["))

*** understanding modifiers to these special keys

+ Emacs recognizes, in principle, that C-TAB, C-RET, C-ESC exist distinctly from TAB, RET, ESC

#+BEGIN_SRC emacs-lisp
  (and
   (equal 105 ?\i)
   (equal 9 ?\t) (equal ?\t ?\C-\i)
   (equal 67108873 ?\C-\t)

   (equal 109 ?m)
   (equal 13 ?\r) (equal ?\r ?\C-m)
   (equal 67108877 ?\C-\r)

   (equal 91 ?\[)
   (equal 27 ?\e) (equal ?\e ?\C-\[)
   (equal 67108891 ?\C-\e))
#+END_SRC

+ If other modifiers but not the `control' modifier are present, there is no distinction between adding those modifiers to C-i, C-m, C-] or to TAB, RET, ESC

#+BEGIN_SRC emacs-lisp 
  (and
   (equal ?\M-\t ?\C-\M-i)
   (equal ?\A-\M-\t ?\A-\C-\M-i)
   (equal ?\A-\M-\r ?\A-\C-\M-m))
#+END_SRC 

*** `event-convert-list' ignores `control' applied to TAB, RET, ESC

#+BEGIN_SRC emacs-lisp
  (and
   (equal (event-convert-list '(control ?\[)) ?\e)

   (equal (event-convert-list '(meta ?\e)) ?\M-\e)
   (equal (event-convert-list '(meta ?\e)) ?\C-\M-\[)

   (equal (event-convert-list '(control meta ?\[)) ?\M-\e)
   (equal (event-convert-list '(control alt ?\[)) ?\A-\e)

   (equal (event-convert-list '(control ?\e)) ?\e)
   (equal (event-convert-list '(control meta ?\e)) ?\M-\e)

   (equal (event-convert-list '(control ?\t)) ?\t)
   (equal (event-convert-list '(control ?\r)) ?\r))
#+END_SRC

*** `event-basic-type', `event-modifiers' act as if TAB, RET, ESC, always has one 'control applied

#+BEGIN_SRC emacs-lisp
  (and
   (equal (event-basic-type ?\e) ?\[)
   (equal (event-basic-type ?\C-\e) ?\[)
   (equal (event-basic-type ?\C-\M-\e) ?\[)

   (equal (event-modifiers ?\e) '(control))
   (equal (event-modifiers ?\C-\e) '(control))
   (equal (event-modifiers ?\M-\e) '(control meta))
   (equal (event-modifiers ?\C-\M-\e) '(control meta)))
#+END_SRC

** `event-basic-type' may not give correct answer unless/until symbol is parsed

An arbitrary random symbol is generally not interned unless done so explicitly. 
#+BEGIN_SRC emacs-lisp
  ;;  First, in case it was already interned during this session, let us simulate
  ;;  starting conditions by unintering `C-m-escape'.
  (unintern "C-M-escape")
  (null (intern-soft "C-M-escape"))
  ;;  Because the symbol has not been parsed, we cannot get the basic type
  (null (event-basic-type 'C-M-escape))
  ;;  however, we can explicitly parse the symbol
  (internal-event-symbol-parse-modifiers 'C-M-escape)
  ;;  Now, `event-basic-type' works
  (eq (event-basic-type 'C-M-escape) 'escape)
  ;;  Note that `event-modifiers' uses `internal-event-symbol-parse-modifiers' in
  ;;  its code and thus always works
  (unintern "C-M-escape")
  (equal (event-modifiers 'C-M-escape) '(meta control))

#+END_SRC

** format of char-tables

The format of a char-table
#^[default-value parent subtype defn-1-(0 . -1) defn-2-(0 . 65535)
   defn-3-(65536 . 131071) ... defn-65-(4128768 . 4194303)]


* old code blurbs that might be useful



;;;; ************************************************
;; test pkb-categorize-key-list
#+BEGIN_SRC emacs-lisp

  (in-pr (pkb-categorize-key-list (pkb-list-keys (current-global-map))))

  (let ((km (make-keymap)))
    (define-key km [?\M-\e] 'bind01)
    (define-key km [?a] 'bind02)
    (define-key km [?\C-a] 'bind03)
    (define-key km [?\C-q] 'bind04)
    (define-key km [?f] 'bind05)
    (define-key km [?g] 'bind06)
    (define-key km [?\M-7] 'bind07)
    (define-key km [?\M-9] 'bind08)
    (define-key km [(?1 . ?9)] 'bind09)
    (define-key km [?\[] 'bind10)
    (let* ((list-keys (pkb-list-keys km nil t))
           (categorized-keys
            (pkb-categorize-key-list list-keys 6 13 '(t t t))))
      (in-pr categorized-keys)
      ;; (in-pr-map 'map-char-table (nth 1 list-keys))
      )) 

  (let ((km (make-keymap)))
    (define-key km [(?1 . ?9)] 'bind9)
    (let* ((list-keys (pkb-list-keys km nil t))
           (categorized-keys
            (pkb-categorize-key-list list-keys 0 13 '(t t t))))
      (in-pr categorized-keys)
      ;; (in-pr-map 'map-char-table (nth 1 list-keys))
      )
  )

  (let ((proc-list-keys
         (pkb-categorize-key-list (pkb-list-keys (current-global-map) nil t)
                                  7 13)))
    (in-pr proc-list-keys))
#+END_SRC

;;;; ************************************************
;; Test pkb-sort-pks-list
#+BEGIN_SRC emacs-lisp

(in-pr (pkb-sort-pks-list
 '(
   ([] simple bks-w-bindings1)
   ([?b] simple ( (?w . binding3) (?\M-t . binding4)))
   ([?u] compact bks-w-bindings2)
   ([?\C-b] simple ( (?a . binding) (?q . binding2) ))
   ([?\C-\M-r] simple ( (?w . binding3) (?\M-t . binding4)))
   ([?t] simple ( (?w . binding3) (?\M-t . binding4)))
  )
 nil
))

(in-pr (pkb-sort-pks-list
 '(
   ([] simple ( (?q . binding1) (?\C-t . binding2)))
   ([?b] simple ( (?w . binding3) (?\M-t . binding4)))
   ([?q] compact compactbind)
  )
 nil
))
#+END_SRC


;;;; ************************************************
;; Test PKB-SPLIT-FULL-TO-GROUPS
#+BEGIN_SRC emacs-lisp

(setq key-groups 
 '( ( ("full")
      (?` ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9 ?0 ?- ?=)
      (?~ ?! ?@ ?# ?$ ?% ?^ ?& ?* ?( ?) ?_ ?+)
      (?q ?w ?e ?r ?t ?y ?u ?i ?o ?p ?[ ?] ?\\ ?{ ?} ?|)
      (?a ?s ?d ?f ?g ?h ?j ?k ?l ?\; ?' ?: ?\")
      (?z ?x ?c ?v ?b ?n ?m ?, ?. ?/ ?< ?> ??))
    ( ("LHS of notebook")
      (insert home prior next end))
  )
)

(let* ((list-keys (pkb-list-keys (current-global-map) nil t))
       (categorized-keys
	(pkb-categorize-key-list list-keys 6 13 t))
       (split-for-full
	(pkb-split-full-to-groups (cdr categorized-keys) key-groups))
       )
  (in-pr split-for-full)
  ;; (in-pr-map 'map-char-table (nth 1 list-keys))
  )
#+END_SRC

;; ************************************************
;; Diagnose issue with SPC and DEL
#+BEGIN_SRC emacs-lisp

(in-pr (key-description (kbd "M-SPC")))
"M-SPC"

(in-pr (event-basic-type (aref (kbd "M-SPC") 0)))
32

(in-pr (event-description (event-basic-type (aref (kbd "M-SPC") 0))))
"SPC"

(in-pr (key-description (kbd "SPC")))
"SPC"

(in-pr (event-basic-type (aref (kbd "SPC")0 )))
32

(in-pr (pkb-list-keys (lookup-key (current-global-map) [f1])))

(in-pr-map 'map-char-table (nth 1 (pkb-list-keys (lookup-key (current-global-map) [f1]))))

(in-pr (pkb-categorize-key-list (pkb-list-keys (lookup-key (current-global-map) [f1])) 4 12))

(in-pr (pkb-split-full-to-groups (cdr (pkb-categorize-key-list (pkb-list-keys (lookup-key (current-global-map) [f1])) 4 12)) pkb-key-groups))
#+END_SRC

;; ************************************************
;; Test program
#+BEGIN_SRC emacs-lisp
  (pkb-html-save-keymap (current-global-map) "~/test.html")
#+END_SRC


* useful commands

** reading events

*** summary of functions for reading events

|                              | (R)ead new    |                                 |           | (N)o prefix   |
|                              | input;        | Single event/key as (C)hr/symb; | (B)efore, | keys;         |
|                              | e(X)amine     | Key-sequence as (S)tr/Vec       | (A)fter   | with (P)refix |
|                              | previous read | Key-sequence as (V)ector        | tsln      | args +        |
|------------------------------+---------------+---------------------------------+-----------+---------------|
| this-single-command-raw-keys | X             | V                               | B         | N             |
| this-single-command-keys     | X             | V                               | A         | N             |
| this-command-keys            | X             | S                               | A         | P             |
| this-command-keys-vector     | X             | V                               | A         | P             |
| read-event                   | R             | C                               | B         | N             |
| read-key                     | R             | C                               | A         | N             |
| read-key-sequence            | R             | S                               | A         | N             |
| read-key-sequence-vector     | R             | V                               | A         | N             |
 + Command only lists prefix arguments when key-sequence not read via `read-key-sequence'


*** function descriptions

**** this-single-command-raw-keys
(this-single-command-raw-keys)

Return the raw events that were read for this command.
More generally, it returns the last key sequence read, either by the command loop or
by `read-key-sequence'.
Unlike `this-single-command-keys', this function's value shows the events before all
translations (except for input methods).
The value is always a vector.

**** this-single-command-keys
(this-single-command-keys)

Return the key sequence that invoked this command.
More generally, it returns the last key sequence read, either by the command loop or
by `read-key-sequence'.
Unlike `this-command-keys', this function's value does not include prefix arguments.
The value is always a vector.

**** this-command-keys
(this-command-keys)

This function returns a string or vector containing the key sequence that invoked the
present command, plus any previous commands that generated the prefix argument for
this command. Any events read by the command using read-event without a timeout get
tacked on to the end.

However, if the command has called read-key-sequence, it returns the last read key
sequence. The value is a string if all events in the sequence were characters that
fit in a string.

**** this-command-keys-vector

(this-command-keys-vector)

Like `this-command-keys', except that it always returns the events in a vector, so
you donâ€™t need to deal with the complexities of storing input events in a string.

**** read-event

(read-event &optional PROMPT INHERIT-INPUT-METHOD SECONDS)

Read an event object from the input stream.
If the optional argument PROMPT is non-nil, display that as a prompt.
If the optional argument INHERIT-INPUT-METHOD is non-nil and some input method is turned on in the current buffer, that input method is used for reading a character.
If the optional argument SECONDS is non-nil, it should be a number specifying the maximum number of seconds to wait for input.  If no input arrives in that time, return nil.  SECONDS may be a floating-point value.

**** read-key

(read-key &optional PROMPT)

Read a key from the keyboard.
Contrary to `read-event' this will not return a raw event but instead will obey the input decoding and translations usually done by `read-key-sequence'. So escape sequences and keyboard encoding are taken into account.
When there's an ambiguity because the key looks like the prefix of some sort of escape sequence, the ambiguity is resolved via `read-key-delay'.

**** read-key-sequence

(read-key-sequence PROMPT &optional CONTINUE-ECHO DONT-DOWNCASE-LAST
CAN-RETURN-SWITCH-FRAME CMD-LOOP)

Read a sequence of keystrokes and return as a string or vector.
The sequence is sufficient to specify a non-prefix command in the current local and global maps.

First arg PROMPT is a prompt string.  If nil, do not prompt specially.
Second (optional) arg CONTINUE-ECHO, if non-nil, means this key echos as a continuation of the previous key.

The third (optional) arg DONT-DOWNCASE-LAST, if non-nil, means do not convert the last event to lower case.  (Normally any upper case event is converted to lower case if the original event is undefined and the lower case equivalent is defined.)  A non-nil value is appropriate for reading a key sequence to be defined.

A C-g typed while in this function is treated like any other character, and `quit-flag' is not set.

If the key sequence starts with a mouse click, then the sequence is read using the keymaps of the buffer of the window clicked in, not the buffer of the selected window as normal.

`read-key-sequence' drops unbound button-down events, since you normally only care about the click or drag events which follow them.  If a drag or multi-click event is unbound, but the corresponding click event would be bound, `read-key-sequence' turns the event into a click event at the drag's starting position.  This means that you don't have to distinguish between click and drag, double, or triple events unless you want to.

`read-key-sequence' prefixes mouse events on mode lines, the vertical lines separating windows, and scroll bars with imaginary keys `mode-line', `vertical-line', and `vertical-scroll-bar'.

Optional fourth argument CAN-RETURN-SWITCH-FRAME non-nil means that this function will process a switch-frame event if the user switches frames before typing anything.  If the user switches frames in the middle of a key sequence, or at the start of the sequence but CAN-RETURN-SWITCH-FRAME is nil, then the event will be put off until after the current key sequence.

`read-key-sequence' checks `function-key-map' for function key sequences, where they wouldn't conflict with ordinary bindings.  See `function-key-map' for more details.

The optional fifth argument CMD-LOOP, if non-nil, means that this key sequence is being read by something that will read commands one after another.  It should be nil if the caller will read just one key sequence.

**** read-key-sequence-vector

(read-key-sequence-vector PROMPT &optional CONTINUE-ECHO DONT-DOWNCASE-LAST
CAN-RETURN-SWITCH-FRAME CMD-LOOP)

Like `read-key-sequence' but always return a vector.


*** related functions/variables
**** meta-prefix-char (variable)

`meta-prefix-char' is a variable defined in `C source code'.

This variable is the meta-prefix character code. It is used for translating a
meta character to a two-character sequence so it can be looked up in a
keymap. For useful results, the value should be a prefix event (see Section 21.6
[Prefix Keys], page 372).  The default value is 27, which is the ASCII code for
ESC.

As long as the value of meta-prefix-char remains 27, key lookup translates M-b
into ESC b, which is normally defined as the backward-word command. However, if
you were to set meta-prefix-char to 24, the code for C-x, then Emacs will
translate M-b into C-x b, whose standard binding is the switch-to-buffer
command.

This translation of one event into two happens only for characters, not for
other kinds of input events. Thus, M-F1, a function key, is not converted into
ESC F1.

**** clear-this-command-keys

(clear-this-command-keys &optional KEEP-RECORD)

Clear out the vector that `this-command-keys' returns.
Also clear the record of the last 100 events, unless optional arg
KEEP-RECORD is non-nil.

**** last-input-event (variable)

This variable records the last terminal input event read, whether as part of a
command or explicitly by a Lisp program.

**** discard-input

(discard-input)

Discard the contents of the terminal input buffer.
Also end any kbd macro being defined.

**** quit-flag (variable)

Non-nil causes `eval' to abort, unless `inhibit-quit' is non-nil.
If the value is t, that means do an ordinary quit.
If the value equals `throw-on-input', that means quit by throwing to the tag specified in `throw-on-input'; it's for handling `while-no-input'.
Typing C-g sets `quit-flag' to t, regardless of `inhibit-quit', but `inhibit-quit' non-nil prevents anything from taking notice of that.

**** inhibit-quit (variable)

Non-nil inhibits C-g quitting from happening immediately.
Note that `quit-flag' will still be set by typing C-g, so a quit will be signaled as soon as `inhibit-quit' is nil. To prevent this happening, set `quit-flag' to nil before making `inhibit-quit' nil.

**** command-history (variable)

List of recent commands that read arguments from terminal. Each command is represented as a form to evaluate.

Maximum length of the history list is determined by the value of `history-length', which see.

**** this-command-keys-shift-translated (variable)

Non-nil if the key sequence activating this command was shift-translated.
Shift-translation occurs when there is no binding for the key sequence as entered,
but a binding was found by changing an upper-case letter to lower-case, or a shifted
function key to an unshifted one.

**** unread-command-events (variable)

List of events to be read as the command input.
These events are processed first, before actual keyboard input.
Events read from this list are not normally added to `this-command-keys', as they
will already have been added once as they were read for the first time.
An element of the form (t . EVENT) forces EVENT to be added to that list.

**** last-command (variable)

The last command executed.
Normally a symbol with a function definition, but can be whatever was found in the
keymap, or whatever the variable `this-command' was set to by that command.

The value `mode-exit' is special; it means that the previous command read an event
that told it to exit, and it did so and unread that event. In other words, the
present command is the event that made the previous command exit.

The value `kill-region' is special; it means that the previous command was a kill
command.

`last-command' has a separate binding for each terminal device.
See Info node `(elisp)Multiple Terminals'.

**** real-last-command (variable)

Same as `last-command', but never altered by Lisp code.
Taken from the previous value of `real-this-command'.

**** last-repeatable-command (variable)

Last command that may be repeated.
The last command executed that was not bound to an input event.
This is the command `repeat' will try to repeat.
Taken from a previous value of `real-this-command'.

**** last-nonmenu-event (variable)

This variable holds the last input event read as part of a key sequence, not counting
events resulting from mouse menus.

**** last-command-event (variable)

This variable is set to the last input event that was read by the command loop as
part of a command. The principal use of this variable is in self-insert-command,
which uses it to decide which character to insert.

**** recent-keys

(recent-keys)

Return vector of last 300 events, not counting those from keyboard macros.

**** listify-key-sequence

(listify-key-sequence KEY)

This function converts the string or vector KEY to a list of individual events, which
you can put in `unread-command-events'.

***** test
(cl-dolist (key '([134217847] [27 119] "w")) 
     (insert (concat (key-description key) ": "))
     (in-pr (listify-key-sequence key))
     (insert "\n"))
M-w: (134217847)
M-w: (27 119)
M-w: (27 119)

[JN: Not so useful]


** resolving events

*** how emacs searches the active keymap

(from elisp.pdf)

21.8 Searching the Active Keymaps
Here is a pseudo-Lisp summary of how Emacs searches the active keymaps:
(or (if overriding-terminal-local-map
	(find-in overriding-terminal-local-map))
    (if overriding-local-map
	(find-in overriding-local-map)
      (or (find-in (get-char-property (point) â€™keymap))
	  (find-in-any emulation-mode-map-alists)
	  (find-in-any minor-mode-overriding-map-alist)
	  (find-in-any minor-mode-map-alist)
	  (if (get-text-property (point) â€™local-map)
	      (find-in (get-char-property (point) â€™local-map))
	    Chapter 21: Keymaps 376
	    (find-in (current-local-map)))))
    (find-in (current-global-map)))
Here, ~find-in~ and ~find-in-any~ are pseudo functions that search in one keymap and
in an alist of keymaps, respectively. Note that the `set-transient-map' function
works by setting `overriding-terminal-local-map' (see Section 21.9 [Controlling
Active Maps], page 376).

*** functions/variables: manipulating/printing events/key-sequences

**** kbd

kbd is a compiled Lisp function in `subr.el'.

(kbd KEYS)

Convert KEYS to the internal Emacs key representation.
KEYS should be a string constant in the format used for saving keyboard macros
(see `edmacro-mode').

**** read-kbd-macro

read-kbd-macro is an interactive autoloaded compiled Lisp function in
`edmacro.el'.

(read-kbd-macro START &optional END)

Read the region as a keyboard macro definition.
The region is interpreted as spelled-out keystrokes, e.g., "M-x abc RET".
See documentation for `edmacro-mode' for details.
Leading/trailing "C-x (" and "C-x )" in the text are allowed and ignored.
The resulting macro is installed as the "current" keyboard macro.

In Lisp, may also be called with a single STRING argument in which case
the result is returned rather than being installed as the current macro.
The result will be a string if possible, otherwise an event vector.
Second argument NEED-VECTOR means to return an event vector always.

**** key-description

(key-description SEQUENCE &optional PREFIX)

This function returns a string containing the Emacs standard notation for the
input events in SEQUENCE. If PREFIX is non-nil, it is a sequence of input events
leading up to SEQUENCE and is included in the return value. Both arguments may
be strings, vectors or lists. See Section 20.7 [Input Events], page 333, for
more information about valid events.

For an approximate inverse of this, see `kbd'.

**** single-key-description

(single-key-description KEY &optional NO-ANGLES)

Return a pretty description of command character KEY.  Optional argument
NO-ANGLES non-nil means don't put angle brackets around function keys and event
symbols.

**** event-convert-list

event-convert-list is a built-in function in `C source code'.

(event-convert-list EVENT-DESC)

Convert the event description list EVENT-DESC to an event type.
EVENT-DESC should contain one base event type (a character or symbol) and zero
or more modifier names (control, meta, hyper, super, shift, alt, drag, down,
double or triple).  The base must be last.
The return value is an event type (a character or symbol) which has the same
base event type and all the specified modifiers.

**** event-basic-type

event-basic-type is a compiled Lisp function in `subr.el'.

(event-basic-type EVENT)

Return the basic type of the given event (all modifiers removed). 
The value is a printing character (not upper case) or a symbol. EVENT may be an
event or an event type.  If EVENT is a symbol that has never been used in an
event that has been read as input in the current Emacs session, then this
function may return nil.


*** functions/variables

**** lookup-key

(lookup-key KEYMAP KEY &optional ACCEPT-DEFAULT)

In keymap KEYMAP, look up key sequence KEY.  Return the definition. A value of
nil means undefined.  See doc of `define-key' for kinds of definitions.

A number as value means KEY is "too long"; that is, characters or symbols in it
except for the last one fail to be a valid sequence of prefix characters in
KEYMAP. The number is how many characters at the front of KEY it takes to reach
a non-prefix key.

Normally, `lookup-key' ignores bindings for t, which act as default bindings,
used when nothing else in the keymap applies; this makes it usable as a general
function for probing keymaps.  However, if the third optional argument
ACCEPT-DEFAULT is non-nil, `lookup-key' will recognize the default bindings,
just as `read-key-sequence' does.

**** current-active-maps

current-active-maps is a built-in function in `C source code'.

(current-active-maps &optional OLP POSITION)

This returns the list of active keymaps that would be used by the command loop
in the current circumstances to look up a key sequence. Normally it ignores
`overriding-local-map' and `overriding-terminal-local-map', but if OLP is
non-nil then it pays attention to them. POSITION can optionally be either an event
position as returned by event-start or a buffer position, and may change the
keymaps as described for key-binding.

**** key-binding

key-binding is a built-in function in `C source code'.

(key-binding KEY &optional ACCEPT-DEFAULT NO-REMAP POSITION)

Return the binding for command KEY in current keymaps.
KEY is a string or vector, a sequence of keystrokes.
The binding is probably a symbol with a function definition.

Normally, `key-binding' ignores bindings for t, which act as default bindings, used
when nothing else in the keymap applies; this makes it usable as a general function
for probing keymaps.  However, if the optional second argument ACCEPT-DEFAULT is
non-nil, `key-binding' does recognize the default bindings, just as
`read-key-sequence' does.

Like the normal command loop, `key-binding' will remap the command resulting from
looking up KEY by looking up the command in the current keymaps.  However, if the
optional third argument NO-REMAP is non-nil, `key-binding' returns the unmapped
command.

If KEY is a key sequence initiated with the mouse, the used keymaps will depend on
the clicked mouse position with regard to the buffer and possible local keymaps on
strings.

If the optional argument POSITION is non-nil, it specifies a mouse position as
returned by `event-start' and `event-end', and the lookup occurs in the keymaps
associated with it instead of KEY.  It can also be a number or marker, in which case
the keymap properties at the specified buffer position instead of point are used.

**** function-key-map (variable)

The parent keymap of all `local-function-key-map' instances.
Function key definitions that apply to all terminal devices should go here.  If
a mapping is defined in both the current `local-function-key-map' binding and
this variable, then the local definition will take precedence.

**** local-function-key-map (variable)

Keymap that translates key sequences to key sequences during input. This is used
mainly for mapping key sequences into some preferred key events (symbols).

The `read-key-sequence' function replaces any subsequence bound by
`local-function-key-map' with its binding.  More precisely, when the active
keymaps have no binding for the current key sequence but
`local-function-key-map' binds a suffix of the sequence to a vector or string,
`read-key-sequence' replaces the matching suffix with its binding, and continues
with the new sequence.

If the binding is a function, it is called with one argument (the prompt) and
its return value (a key sequence) is used.

The events that come from bindings in `local-function-key-map' are not
themselves looked up in `local-function-key-map'.

For example, suppose `local-function-key-map' binds `ESC O P' to [f1]. Typing
`ESC O P' to `read-key-sequence' would return [f1].  Typing `C-x ESC O P' would
return [?\C-x f1].  If [f1] were a prefix key, typing `ESC O P x' would return
[f1 x].

`local-function-key-map' has a separate binding for each terminal device.  See
Info node `(elisp)Multiple Terminals'.  If you need to define a binding on all
terminals, change `function-key-map' instead.  Initially,
`local-function-key-map' is an empty keymap that has `function-key-map' as its
parent on all terminal devices.

**** extra-keyboard-modifiers (variable)

A mask of additional modifier keys to use with every keyboard character.
Emacs applies the modifiers of the character stored here to each keyboard character
it reads.  For example, after evaluating the expression
    (setq extra-keyboard-modifiers ?\C-x)
all input characters will have the control modifier applied to them.

Note that the character ?\C-@, equivalent to the integer zero, does not count as a
control character; rather, it counts as a character with no modifiers; thus, setting
`extra-keyboard-modifiers' to zero cancels any modification.

**** current-global-map

current-global-map is a built-in function in `C source code'.

(current-global-map)

Return the current global keymap.

**** global-map (variable)

Default global keymap mapping Emacs keyboard input into commands.
This will be the same as `current-global-map' unless unless the current global keymap has been pointed elsewhere (using, e.g. 'use-global-map')

Thus, the following is usually true:
     (eq (current-global-map) global-map)

**** current-local-map

current-local-map is a built-in function in `C source code'.

(current-local-map)

Return current buffer's local keymap, or nil if it has none.
Normally the local keymap is set by the major mode with `use-local-map'.

**** keymap-canonicalize

keymap-canonicalize is a compiled Lisp function in `subr.el'.

(keymap-canonicalize MAP)

Return a simpler equivalent keymap.
This resolves inheritance and redefinitions.  The returned keymap
should behave identically to a copy of KEYMAP w.r.t `lookup-key'
and use in active keymaps and menus.
Subkeymaps may be modified but are not canonicalized.


*** event translation

**** overview

(elisp.pdf) 

When `read-key-sequence' reads a key sequence, it uses the translation keymaps
`input-decode-map', `local-function-key-map', and `key-translation-map' (in
order of priority).

Translation keymaps specify translations to make while reading key sequences,
rather than bindings for complete key sequences. As each key sequence is read,
it is checked against each translation keymap. If one of the translation keymaps
binds a sequence k to a vector v, then whenever k appears as a sub-sequence
*anywhere* in a key sequence, that sub-sequence is replaced with the events in
v.

**** translation keymaps

***** input-decode-map (variable)

input-decode-map is a variable defined in `C source code'.

This variable holds a keymap that describes the character sequences sent by
function keys on an ordinary character terminal.

The `read-key-sequence' function replaces any subsequence bound by
`input-decode-map' with its binding.  Contrary to `function-key-map', this map
applies its rebinding regardless of the presence of an ordinary binding.  So it
is more like `key-translation-map' except that it applies before
`function-key-map' rather than after.

The events that come from bindings in `input-decode-map' are not themselves
looked up in `input-decode-map'.

The value of `input-decode-map' is usually set up automatically according to the
terminalâ€™s Terminfo or Termcap entry, but sometimes those need help from
terminal-specific Lisp files. Emacs comes with terminal-specific files for many
common terminals; their main purpose is to make entries in `input-decode-map'
beyond those that can be deduced from Termcap and Terminfo. See Section 38.1.3
[Terminal-Specific].

***** local-function-key-map (variable)
 
***** key-translation-map (variable)

**** functions
***** keyboard-translate-table (variable)

Translate table for local keyboard input, or nil.
If non-nil, the value should be a char-table.  Each character read from the keyboard
is looked up in this char-table.  If the value found there is non-nil, then it is
used instead of the actual input character.

The value can also be a string or vector, but this is considered obsolete. If it is a
string or vector of length N, character codes N and up are left untranslated.  In a
vector, an element which is nil means "no translation".

This is applied to the characters supplied to input methods, not their output.  See
also `translation-table-for-input'.

This variable has a separate binding for each terminal.
See Info node `(elisp)Multiple Terminals'.



***** function-key-map (variable)

The parent keymap of all `local-function-key-map' instances.
Function key definitions that apply to all terminal devices should go here.  If
a mapping is defined in both the current `local-function-key-map' binding and
this variable, then the local definition will take precedence.

`local-function-key-map' inherits from `function-key-map', but the latter should
not be used directly.

*** prefix keys

**** understanding why some prefix keys are in a variable's function slot

(from elisp.pdf)

The keymap binding of a prefix key is used for looking up the event that follows the
prefix key. (It may instead be a symbol whose function definition is a keymap. The
effect is the same, but the symbol serves as a name for the prefix key.) Thus, the
binding of C-x is the symbol Control-X-prefix, whose function cell holds the keymap
for C-x commands. (The same keymap is also the value of ctl-x-map.)

**** global emacs prefix keys

More are listed in the Emacs Lisp manual, App. G

| prefix  | as variable       | as function definition | notes                     |
|---------+-------------------+------------------------+---------------------------|
| ESC     | esc-map           | ESC-prefix             | global definitions of all |
|         |                   |                        | meta characters are here  |
| C-h     | help-map          | help-command           |                           |
| C-c     | mode-specific-map | mode-specific          | despite name, is global,  |
|         |                   | -command-prefix        | not mode specific         |
| C-x     | ctl-x-map         | Control-X-prefix       |                           |
| C-x RET | mule-keymap       |                        |                           |
| C-x 4   | ctl-x-4-map       | ctl-x-4-prefix         |                           |
| C-x 5   | ctl-x-5-map       | ctl-x-5-prefix         |                           |
| C-x 6   | 2C-mode-map       | 2C-command             |                           |
| C-x r   | ctl-x-r-map       |                        |                           |
| C-x v   | vc-prefix-map     | vc-prefix-map          |                           |
| M-g     | goto-map          |                        |                           |
| M-s     | search-map        |                        |                           |
| M-o     | facemenu-keymap   | facemenu-keymap        |                           |
| C-x @   | (none)            |                        |                           |
| C-x a   | abbrev-map        |                        |                           |
| C-x a i | (none)            |                        |                           |
| C-x ESC | (none)            |                        |                           |
| ESC-ESC | (none)            |                        |                           |

***** see relations

(let (lookup-global)
  (defun lookup-global (seq) (lookup-key global-map seq))
  (and
   ;; ESC
   (eq (lookup-global [?\e]) 'ESC-prefix)
   (eq (symbol-function 'ESC-prefix) esc-map)
   ;; C-h
   (eq (lookup-global [?\C-h]) 'help-command)
   (eq (symbol-function 'help-command) help-map)
   ;; C-c
   (eq (lookup-global [?\C-c]) 'mode-specific-command-prefix)
   (eq (symbol-function 'mode-specific-command-prefix) mode-specific-map)
   ;; C-x
   (eq (lookup-global [?\C-x]) 'Control-X-prefix)
   (eq (symbol-function 'Control-X-prefix) ctl-x-map)
   ;; C-x RET
   (eq (lookup-global [?\C-x ?\r]) mule-keymap)
   ;; C-x 4
   (eq (lookup-global [?\C-x ?4]) 'ctl-x-4-prefix)
   (eq (symbol-function 'ctl-x-4-prefix) ctl-x-4-map)
   ;; C-x 5
   (eq (lookup-global [?\C-x ?5]) 'ctl-x-5-prefix)
   (eq (symbol-function 'ctl-x-5-prefix) ctl-x-5-map)
   ;; C-x 6
   (eq (lookup-global [?\C-x ?6]) '2C-command)
   (eq (symbol-function '2C-command) 2C-mode-map)
   ;; C-x v
   (eq (lookup-global [?\C-x ?v]) 'vc-prefix-map)
   (eq (symbol-function 'vc-prefix-map) vc-prefix-map)
   ;; M-g
   (eq (lookup-global [?\M-g]) goto-map)
   ;; M-s
   (eq (lookup-global [?\M-s]) search-map)
   ;; M-o
   (eq (lookup-global [?\M-o]) 'facemenu-keymap)
   (eq (symbol-function 'facemenu-keymap) facemenu-keymap)))

**** translated prefix keys

Currently, 
  (in-pr key-translation-map)
  (keymap (24 keymap (56 . iso-transl-ctl-x-8-map)))


** note

*** 1
From elisp.pdf 
"The editor command loop reads key sequences using the function `read-key-sequence',
which uses `read-event'"

*** 2
(elisp.pdf)

This translation of one event into two happens only for characters, not for
other kinds of input events. Thus, M-F1, a function key, is not converted into
ESC F1.


* representing characters

** useful functions

*** aref (for extracting characters from string)

e.g.
(= (aref "abc" 0) ?a)

*** string (for converting characters to strings)

(equal (string ?a) "a")

*** concat (vector or list into string)

*** vconcat (string into vector)

*** append (string into list of chars)

*** byte-to-string

byte-to-string is a built-in function in `C source code'.

(byte-to-string BYTE)

Convert arg BYTE to a unibyte string containing that byte.

** character escape sequences syntax

  +---------------+-------------+--------------------+----------------+
  | name          |   form...   | ...means           | e.g.           |
  +---------------+-------------+--------------------+----------------+
  | Unicode       | ?\unnnn     | Unicode 'U+nnnn',  | ?\u0032 is 2   |
  | 4 hex digits  |             | with hex codepoint |                |
  |               |             | nnnn               |                |
  +---------------+-------------+--------------------+----------------+
  | Unicode      | ?\U00nnnnnn | Unicode 'U+nnnnnn' |   |
  | 6 hex digits |             | with hex codepoint |   |
  |              |             | nnnnnn             |   |
  +---------------+-------------+--------------------+----------------+
  | character code| ?\xnn       | any variable length|                |
  | hex           |             | character code nn  |                |
  +---------------+-------------+--------------------+----------------+
  | character code| ?\nnn       | up to three octal  |                |
  | octal         |             | digits nnn         |                |
  +---------------+-------------+--------------------+----------------+
     
** how emacs relates modified and unmodified characters

| ascii key | ascii code | modified char |
|-----------+------------+---------------|
| DEL (?\d) |        127 | C-? (?\C-\?)  |


The delete character is 127
(eq ?\C-\? ?\d)

** how are modifier bits configured

From 20.7.1 Keyboards Events

|          | 2^x bit in | (if different)    |                  |
| modifier |  character | 2^x bit in string | character prefix |
|----------+------------+-------------------+------------------|
| meta     |         27 | 7                 | \M               |
| control  |         26 |                   | \C               |
| shift    |         25 |                   | \S               |
| hyper    |         24 |                   | \H               |
| super    |         23 |                   | \s               |
| alt      |         22 |                   | \A               |

(= ?\M-Â€ (+ ?Â€ (expt 2 27)))
(= ?\C-Â€ (+ ?Â€ (expt 2 26)))
(= ?\S-Â€ (+ ?Â€ (expt 2 25)))
(= (aref "\M-a" 0) (+ 128 ?a))

*** control

(elisp.pdf)

In strings and buffers, the only control characters allowed are those that exist
in ASCII; but for keyboard input purposes, you can turn any character into a
control character with â€˜C-â€™. The character codes for these non-ASCII control
characters include the 2^26 bit as well as the code for the corresponding
non-control character.


** useful functions

*** logior: bitwise or

*** logand: bitwise and
*** lognot: bitwise complement
*** logxor: bitwise exclusive-or
*** convert to binary

#+BEGIN_SRC emacs-lisp 
  (require 'calc-bin)

  (let ((calc-number-radix 2))
    (in-pr (math-format-radix ?\A-\^@)))
  "10000000000000000000000"

  (let ((calc-number-radix 2))
    (in-pr (math-format-radix ?\@)))
  "1000000"

  (let ((calc-number-radix 2))
    (in-pr (math-format-radix ?\A-\@)))
  "10000000000000001000000"

  (let ((calc-number-radix 2))
    (in-pr (math-format-radix
            (lsh (lsh (lognot (logior ?\M-\^@ ?\C-\^@ ?\S-\^@
                                      ?\H-\^@ ?\s-\^@ ?\A-\^@)) 1) -1))))
  "1111111111111111111111111111111110000001111111111111111111111"

  (in-pr (log ?\A-\^@ 2))
  22.0
#+END_SRC 
